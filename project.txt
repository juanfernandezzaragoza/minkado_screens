=== FILE STRUCTURE ===

src/app/action/[actionId]/page.js
src/app/crear-minka/page.js
src/app/debug/page.js
src/app/describir-accion/page.js
src/app/emprender-viaje/page.js
src/app/globals.css
src/app/layout.js
src/app/minka/[minkaId]/page.js
src/app/minka/[minkaId]/valuations/page.js
src/app/mis-movimientos/page.js
src/app/pactar/page.js
src/app/page.js
src/app/pescadores/page.js
src/app/reportar-acto/page.js
src/app/transferir/page.js
src/app/validar-acto/page.js
src/app/valorar-accion/page.js
src/app/valorar-nueva-accion/page.js
src/components/layouts/AppLayout.jsx
src/components/screens/ActionDetailScreen.jsx
src/components/screens/CrearMinkaScreen.jsx
src/components/screens/DescribirAccionScreen.jsx
src/components/screens/EmprenderViajeScreen.jsx
src/components/screens/HomeScreen.jsx
src/components/screens/MinkaDetailScreen.jsx
src/components/screens/MinkaValuationsScreen.jsx
src/components/screens/MisMovimientosScreen.jsx
src/components/screens/PactarScreen.jsx
src/components/screens/PescadoresDetailScreen.jsx
src/components/screens/ReportarActoScreen.jsx
src/components/screens/TransferirScreen.jsx
src/components/screens/ValidarActoScreen.jsx
src/components/screens/ValorarAccionScreen.jsx
src/components/screens/ValorarNuevaAccionScreen.jsx
src/components/shared/FormField.jsx
src/components/shared/MarkdownEditor.jsx
src/components/shared/MarkdownViewer.jsx
src/components/shared/SearchInput.jsx
src/components/ui/ActionButton.jsx
src/components/ui/ActionItem.jsx
src/components/ui/ActionRow.jsx
src/components/ui/Card.jsx
src/components/ui/CaseItem.jsx
src/components/ui/CreateMinkaButton.jsx
src/components/ui/GradientCard.jsx
src/components/ui/Header.jsx
src/components/ui/ListItem.jsx
src/components/ui/MinkaListItem.jsx
src/components/ui/MovementItem.jsx
src/components/ui/SectionTitle.jsx
src/components/ui/ValuationChart.jsx
src/data/index.js
src/services/dataService.js
src/styles/theme.js
src/utils/navigation.js

=== FILE CONTENTS ===

//src/app/action/[actionId]/page.js

import ActionDetailScreen from '@/components/screens/ActionDetailScreen';
import AppLayout from '@/components/layouts/AppLayout';
import { dataService } from '@/services/dataService';

export default async function ActionPage({ params, searchParams }) {
  const { actionId } = await params;
  const resolvedSearchParams = await searchParams;
  const minkaId = resolvedSearchParams?.minka; //Default to pescadores
  
  // Fetch the complete action details
  const action = await dataService.getAction(actionId);
  
  // Fetch minka context if provided
  let minkaContext = null;
  if (minkaId) {
    try {
      minkaContext = await dataService.getMinka(minkaId);
    } catch (error) {
      console.error('Error fetching minka context:', error);
    }
  }
  
  // Handle not found
  if (!action) {
    return (
      <AppLayout showBackButton={true}>
        <div className="m-4 text-center">
          <h1 className="text-xl font-bold text-gray-800">Acción no encontrada</h1>
          <p className="text-gray-600 mt-2">La acción que buscás no existe.</p>
        </div>
      </AppLayout>
    );
  }
  
  return (
    <AppLayout showBackButton={true}>
      <ActionDetailScreen action={action} minkaContext={minkaContext} />
    </AppLayout>
  );
}


//src/app/crear-minka/page.js


import CrearMinkaScreen from '@/components/screens/CrearMinkaScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default function CrearMinkaPage() {
  return (
    <AppLayout showBackButton={true}>
      <CrearMinkaScreen />
    </AppLayout>
  );
}


//src/app/debug/page.js

// src/app/debug/page.js
import { dataService } from '@/services/dataService';
import { mockActionDetails } from '@/data';

export default async function DebugPage() {
  // Test direct import
  const directImport = mockActionDetails;
  
  // Test dataService
  const actionFromService = await dataService.getAction('emprender-viaje');
  
  // Get all actions
  const allActions = await dataService.getActions();
  
  return (
    <div className="p-8 max-w-4xl mx-auto">
      <h1 className="text-2xl font-bold mb-4">Debug Page</h1>
      
      <section className="mb-8">
        <h2 className="text-xl font-semibold mb-2">Direct Import Test</h2>
        <pre className="bg-gray-100 p-4 rounded overflow-auto">
          mockActionDetails exists: {directImport ? 'YES' : 'NO'}
          {'\n'}
          Keys: {directImport ? Object.keys(directImport).join(', ') : 'N/A'}
        </pre>
      </section>
      
      <section className="mb-8">
        <h2 className="text-xl font-semibold mb-2">DataService Test</h2>
        <pre className="bg-gray-100 p-4 rounded overflow-auto">
          Action from service: {actionFromService ? 'FOUND' : 'NOT FOUND'}
          {'\n'}
          {actionFromService && JSON.stringify(actionFromService, null, 2)}
        </pre>
      </section>
      
      <section className="mb-8">
        <h2 className="text-xl font-semibold mb-2">All Actions</h2>
        <pre className="bg-gray-100 p-4 rounded overflow-auto">
          Total actions: {allActions.length}
          {'\n'}
          Action IDs: {allActions.map(a => a.id).join(', ')}
        </pre>
      </section>
    </div>
  );
}


//src/app/describir-accion/page.js

import DescribirAccionScreen from '@/components/screens/DescribirAccionScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default function DescribirAccionPage() {
  return (
    <AppLayout showBackButton={true}>
      <DescribirAccionScreen />
    </AppLayout>
  );
}


//src/app/emprender-viaje/page.js

import EmprenderViajeScreen from '@/components/screens/EmprenderViajeScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default function EmprenderViajePage() {
  return (
    <AppLayout showBackButton={true}>
      <EmprenderViajeScreen />
    </AppLayout>
  );
}


//src/app/globals.css

@import "tailwindcss";

@import '@uiw/react-md-editor/markdown-editor.css';
@import '@uiw/react-markdown-preview/markdown.css';

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #2c2626;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

.markdown-editor .w-md-editor {
  background-color: transparent;
}

.markdown-editor .w-md-editor-text-textarea,
.markdown-editor .w-md-editor-text {
  font-size: 14px !important;
  line-height: 1.5 !important;
}

.markdown-editor .w-md-editor.w-md-editor-focus {
  border-color: #3b82f6 !important;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2) !important;
}


//src/app/layout.js

import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata = {
  title: "Minkado",
  description: "Finanzas comunitarias",
  icons: {
    icon: '/favicon.ico',
    shortcut: '/favicon.ico',
    apple: '/favicon.ico',
  },
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}



//src/app/minka/[minkaId]/page.js

import MinkaDetailScreen from '@/components/screens/MinkaDetailScreen';
import AppLayout from '@/components/layouts/AppLayout';
import { dataService } from '@/services/dataService';

export default async function MinkaPage({ params }) {
  const { minkaId } = await params;
  
  // Fetch minka data
  const minka = await dataService.getMinka(minkaId);
  const actions = await dataService.getMinkaActions(minkaId);
  const subMinkas = await dataService.getSubMinkas(minkaId);
  
  // Handle not found
  if (!minka) {
    return (
      <AppLayout showBackButton={true}>
        <div className="m-4 text-center">
          <h1 className="text-xl font-bold text-gray-800">Minka no encontrada</h1>
          <p className="text-gray-600 mt-2">La minka que buscás no existe.</p>
        </div>
      </AppLayout>
    );
  }
  
  return (
    <AppLayout showBackButton={true}>
      <MinkaDetailScreen 
        minka={minka}
        actions={actions}
        subMinkas={subMinkas}
      />
    </AppLayout>
  );
}


//src/app/minka/[minkaId]/valuations/page.js

import MinkaValuationsScreen from '@/components/screens/MinkaValuationsScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default async function MinkaValuationsPage({ params }) {
  // Await the params as required by Next.js 13+
  const resolvedParams = await params;
  
  // Debug: Let's see exactly what we're getting
  console.log('=== MinkaValuationsPage Debug ===');
  console.log('Resolved params:', resolvedParams);
  console.log('minkaId value:', resolvedParams?.minkaId);
  console.log('================================');

  // Show debug info on screen too
  return (
    <AppLayout showBackButton={true}>
      
      <MinkaValuationsScreen minkaId={resolvedParams?.minkaId} />
    </AppLayout>
  );
}


//src/app/mis-movimientos/page.js

import MisMovimientosScreen from '@/components/screens/MisMovimientosScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default function MisMovimientosPage() {
  return (
    <AppLayout showBackButton={true}>
      <MisMovimientosScreen />
    </AppLayout>
  );
}


//src/app/pactar/page.js

import PactarScreen from '@/components/screens/PactarScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default function PactarPage() {
  return (
    <AppLayout showBackButton={true}>
      <PactarScreen />
    </AppLayout>
  );
}


//src/app/page.js

import HomeScreen from '@/components/screens/HomeScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default function Home() {
  return (
    <AppLayout>
      <HomeScreen />
    </AppLayout>
  );
}


//src/app/pescadores/page.js

import PescadoresDetailScreen from '@/components/screens/PescadoresDetailScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default function PescadoresPage() {
  return (
    <AppLayout>
      <PescadoresDetailScreen />
    </AppLayout>
  );
}


//src/app/reportar-acto/page.js


import ReportarActoScreen from '@/components/screens/ReportarActoScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default function ReportarActoPage() {
  return (
    <AppLayout showBackButton={true}>
      <ReportarActoScreen />
    </AppLayout>
  );
}


//src/app/transferir/page.js


import TransferirScreen from '@/components/screens/TransferirScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default function TransferirPage() {
  return (
    <AppLayout showBackButton={true}>
      <TransferirScreen />
    </AppLayout>
  );
}


//src/app/validar-acto/page.js

import ValidarActoScreen from '@/components/screens/ValidarActoScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default function ValidarActoPage() {
  return (
    <AppLayout showBackButton={true}>
      <ValidarActoScreen />
    </AppLayout>
  );
}


//src/app/valorar-accion/page.js

import ValorarAccionScreen from '@/components/screens/ValorarAccionScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default async function ValorarAccionPage({ searchParams }) {
  const resolvedSearchParams = await searchParams;
  
  return (
    <AppLayout showBackButton={true}>
      <ValorarAccionScreen searchParams={resolvedSearchParams} />
    </AppLayout>
  );
}


//src/app/valorar-nueva-accion/page.js

import ValorarNuevaAccionScreen from '@/components/screens/ValorarNuevaAccionScreen';
import AppLayout from '@/components/layouts/AppLayout';

export default function ValorarNuevaAccionPage() {
  return (
    <AppLayout showBackButton={true}>
      <ValorarNuevaAccionScreen />
    </AppLayout>
  );
}


//src/components/layouts/AppLayout.jsx

import React from 'react';
import Header from '../ui/Header';

export default function AppLayout({ children, showBackButton = false }) {
  return (
    <div className="max-w-md mx-auto bg-gray-50 min-h-screen overflow-auto font-sans text-black">
      <Header showBackButton={showBackButton} />
      <main className="pb-20">
        {children}
      </main>
    </div>
  );
}



//src/components/screens/ActionDetailScreen.jsx

// src/components/screens/ActionDetailScreen.jsx - Updated for pure actions
"use client";

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { 
  Fish, 
  MapPin, 
  ShoppingBag, 
  Baby, 
  Globe, 
  Users, 
  Heart,
  Leaf,
  Car,
  Briefcase,
  Home,
  ArrowLeftRight,
  Code,
  FileText
} from 'lucide-react';
import Card from '@/components/ui/Card';
import SectionTitle from '@/components/ui/SectionTitle';
import CaseItem from '@/components/ui/CaseItem';
import ValuationChart from '@/components/ui/ValuationChart';
import MarkdownViewer from '@/components/shared/MarkdownViewer';
import { dataService } from '@/services/dataService';

// Extended icon mapping for all possible icons
const iconMap = {
  Fish: Fish,
  MapPin: MapPin,
  ShoppingBag: ShoppingBag,
  Baby: Baby,
  Globe: Globe,
  Users: Users,
  Heart: Heart,
  Leaf: Leaf,
  Car: Car,
  Briefcase: Briefcase,
  Home: Home,
  ArrowLeftRight: ArrowLeftRight,
  Code: Code,
  FileText: FileText,
};

export default function ActionDetailScreen({ action, minkaContext = null }) {
  const router = useRouter();
  const [valuation, setValuation] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  
  // Default to pescadores if no minka context provided
  const currentMinkaId = minkaContext?.id || 'pescadores';
  
  useEffect(() => {
    loadValuation();
  }, [action.id, currentMinkaId]);

  const loadValuation = async () => {
    try {
      const actionValuation = await dataService.getActionValuation(currentMinkaId, action.id);
      setValuation(actionValuation);
    } catch (error) {
      console.error('Error loading valuation:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Get the appropriate icons
  const ActionIcon = iconMap[action.icon] || MapPin;
  
  // Determine scope icon based on valuation
  let ScopeIcon, scopeLabel, scopeIconColor;
  
  if (valuation) {
    if (valuation.associatedMinka === 'global') {
      ScopeIcon = Globe;
      scopeLabel = 'Global';
      scopeIconColor = 'text-green-600';
    } else if (valuation.complement) {
      // For complement, show the icon with indication
      ScopeIcon = iconMap[minkaContext?.icon] || Fish;
      scopeLabel = `No ${valuation.associatedMinka}`;
      scopeIconColor = 'text-red-600';
    } else {
      ScopeIcon = iconMap[minkaContext?.icon] || Fish;
      scopeLabel = valuation.associatedMinka;
      scopeIconColor = minkaContext?.iconColor || 'text-blue-600';
    }
  } else {
    // Default if no valuation
    ScopeIcon = Fish;
    scopeLabel = 'No valorado';
    scopeIconColor = 'text-gray-400';
  }

  // Format valuation value
  let valueDisplay, valueColor;
  
  if (valuation) {
    if (valuation.isExchange) {
      valueDisplay = `⇆ ${valuation.exchangePercentage}%`;
      valueColor = 'text-gray-600';
    } else {
      const isPositive = valuation.value >= 0;
      valueDisplay = `${isPositive ? '+' : ''}₭${Math.abs(valuation.value)}`;
      valueColor = isPositive ? 'text-green-600' : 'text-red-600';
    }
  } else {
    valueDisplay = 'No valorado';
    valueColor = 'text-gray-400';
  }

  return (
    <>
      {/* Action Description Card */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <h1 className="text-xl font-bold text-gray-800 mb-3">{action.name}</h1>
            <p className="text-gray-700 text-sm leading-relaxed">
              {action.description}
            </p>
          </div>
        </Card>
      </div>

      {/* Applies To Section - Only show if there's a valuation */}
      {valuation && (
        <div className="px-4 pb-4">
          <Card>
            <div className="p-4 flex items-center">
              <div className="w-6 h-6 rounded bg-gray-100 flex items-center justify-center mr-3">
                <ScopeIcon size={16} className={scopeIconColor} />
              </div>
              <span className="text-gray-800 font-medium">
                Aplica a {scopeLabel}
                {valuation.complement && ' (complemento)'}
              </span>
            </div>
          </Card>
        </div>
      )}

      {/* Current Valuation - Only show if there's a valuation and it's not exchange */}
      {valuation && !valuation.isExchange && (
        <div className="px-4 pb-4">
          <Card className="p-4">
            <ValuationChart 
              title="Valoración actual"
              currentValue={valueDisplay}
              avgValue={`+₭${valuation.medianValue}`}
              totalImpact={`+₭${valuation.totalImpact}`}
              showValuationInfo={true}
              actionId={action.id}
              minkaId={currentMinkaId}
            />
          </Card>
        </div>
      )}

      {/* Exchange Information - Only show for exchange type actions */}
      {valuation && valuation.isExchange && (
        <div className="px-4 pb-4">
          <Card className="p-4">
            <div className="flex items-center mb-3">
              <ArrowLeftRight size={20} className="text-purple-600 mr-2" />
              <h3 className="font-medium text-gray-800">Intercambio automático</h3>
            </div>
            <div className="bg-purple-50 border border-purple-200 rounded-lg p-4">
              <p className="text-purple-800">
                Esta acción activa un intercambio de <strong>{valueDisplay}</strong> entre los participantes del pacto.
              </p>
            </div>
          </Card>
        </div>
      )}

      {/* Time-based Valuation - Only show if not exchange type */}
      {valuation && !valuation.isExchange && (
        <div className="px-4 pb-4">
          <Card className="p-4">
            <ValuationChart 
              title="Valoración en el tiempo"
              showTimeChart={true}
              showValuationInfo={false}
            />
          </Card>
        </div>
      )}

      {/* Recent Cases Section */}
      {action.recentCases && action.recentCases.length > 0 && (
        <>
          <SectionTitle 
            title="Últimos casos" 
            actionText="Ver todos" 
            onAction={() => console.log('Ver todos casos')} 
          />

          <div className="px-4 pb-4">
            <Card>
              {action.recentCases.map((caseItem, index) => (
                <CaseItem 
                  key={index}
                  name={caseItem.name}
                  time={caseItem.time}
                  date={caseItem.date}
                  value={caseItem.value}
                  isPositive={caseItem.isPositive}
                />
              ))}
            </Card>
          </div>
        </>
      )}

      {/* Full Description Section */}
      {action.fullDescription && (
        <>
          <SectionTitle title="Descripción completa" />
          
          <div className="px-4 pb-4">
            <Card>
              <div className="p-5">
                <div className="prose prose-sm max-w-none">
                  <MarkdownViewer content={action.fullDescription} />
                </div>
              </div>
            </Card>
          </div>
        </>
      )}

      {/* No Valuation Notice */}
      {!valuation && (
        <div className="px-4 pb-4">
          <Card className="p-4">
            <div className="text-center">
              <h3 className="font-medium text-gray-800 mb-2">No valorado por {minkaContext?.name || 'esta minka'}</h3>
              <p className="text-gray-600 text-sm mb-4">
                {minkaContext?.name || 'Esta minka'} aún no ha establecido una valoración para esta acción.
              </p>
              <button 
                onClick={() => router.push(`/valorar-nueva-accion?minka=${currentMinkaId}&action=${action.id}`)}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm"
              >
                Crear valoración
              </button>
            </div>
          </Card>
        </div>
      )}

      {/* Action Buttons */}
      <div className="px-4 pb-6 space-y-3">
        {/* Report this action */}
        <button 
          onClick={() => router.push(`/reportar-acto?action=${action.id}`)}
          className="w-full py-3 px-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"
        >
          Reportar que alguien hizo esta acción
        </button>
        
        {/* Valorate this action - only if there's a valuation and it's not exchange type */}
        {valuation && !valuation.isExchange && (
          <button 
            onClick={() => router.push(`/valorar-nueva-accion?minka=${currentMinkaId}&action=${action.id}`)}
            className="w-full py-3 px-4 bg-purple-600 text-white rounded-lg hover:bg-purple-700 font-medium"
          >
            Cambiar valoración de {minkaContext?.name || 'esta minka'}
          </button>
        )}
        
        {/* Create pact - only for exchange type actions */}
        {valuation && valuation.isExchange && (
          <button 
            onClick={() => router.push(`/pactar?action=${action.id}`)}
            className="w-full py-3 px-4 bg-purple-600 text-white rounded-lg hover:bg-purple-700 font-medium"
          >
            Crear pacto con esta acción
          </button>
        )}

        {/* Create valuation - only if no valuation exists */}
        {!valuation && (
          <button 
            onClick={() => router.push(`/valorar-nueva-accion?minka=${currentMinkaId}&action=${action.id}`)}
            className="w-full py-3 px-4 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
          >
            Crear valoración para {minkaContext?.name || 'esta minka'}
          </button>
        )}
      </div>
    </>
  );
}


//src/components/screens/CrearMinkaScreen.jsx

"use client";

import React, { useState } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { CheckCircle, AlertCircle, User, X, ChevronLeft, Fish, Users, Briefcase, Heart, Gamepad2, Music, Camera, Book, Zap, Target, Coffee, Palette, Code, Cpu, Globe } from 'lucide-react';
import Card from '@/components/ui/Card';
import FormField from '@/components/shared/FormField';
import SearchInput from '@/components/shared/SearchInput';
import { dataService } from '@/services/dataService';

export default function CrearMinkaScreen() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const parentMinkaId = searchParams?.get('parent'); // Viene del contexto de otra minka
  
  // Form data
  const [nombre, setNombre] = useState('');
  const [descripcion, setDescripcion] = useState('');
  const [selectedIcon, setSelectedIcon] = useState(null);
  const [selectedParentMinka, setSelectedParentMinka] = useState(null);
  const [selectedUsers, setSelectedUsers] = useState([]);
  
  // UI state
  const [currentStep, setCurrentStep] = useState(1);
  const [userSearchResults, setUserSearchResults] = useState([]);
  const [iconSearchQuery, setIconSearchQuery] = useState('');
  const [minkaSearchQuery, setMinkaSearchQuery] = useState('');
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);

  // Available icons for minkas (expandida para búsqueda)
  const availableIcons = [
    { name: 'Fish', component: Fish, color: 'text-blue-600', keywords: ['pez', 'pescado', 'mar', 'océano'] },
    { name: 'Users', component: Users, color: 'text-purple-600', keywords: ['usuarios', 'gente', 'personas', 'comunidad'] },
    { name: 'Briefcase', component: Briefcase, color: 'text-gray-600', keywords: ['trabajo', 'oficina', 'negocio', 'empresa'] },
    { name: 'Heart', component: Heart, color: 'text-red-600', keywords: ['corazón', 'amor', 'salud', 'bienestar'] },
    { name: 'Gamepad2', component: Gamepad2, color: 'text-green-600', keywords: ['juegos', 'gaming', 'entretenimiento'] },
    { name: 'Music', component: Music, color: 'text-pink-600', keywords: ['música', 'sonido', 'audio', 'banda'] },
    { name: 'Camera', component: Camera, color: 'text-indigo-600', keywords: ['cámara', 'foto', 'fotografía', 'imagen'] },
    { name: 'Book', component: Book, color: 'text-yellow-600', keywords: ['libro', 'lectura', 'educación', 'estudio'] },
    { name: 'Zap', component: Zap, color: 'text-orange-600', keywords: ['energía', 'rayo', 'eléctrico', 'poder'] },
    { name: 'Target', component: Target, color: 'text-teal-600', keywords: ['objetivo', 'meta', 'blanco', 'precisión'] },
    { name: 'Coffee', component: Coffee, color: 'text-amber-600', keywords: ['café', 'bebida', 'desayuno', 'energía'] },
    { name: 'Palette', component: Palette, color: 'text-rose-600', keywords: ['paleta', 'arte', 'pintura', 'diseño', 'colores'] },
    { name: 'Code', component: Code, color: 'text-emerald-600', keywords: ['código', 'programación', 'desarrollo', 'tech'] },
    { name: 'Cpu', component: Cpu, color: 'text-slate-600', keywords: ['computadora', 'tecnología', 'hardware', 'procesador'] },
    { name: 'Globe', component: Globe, color: 'text-cyan-600', keywords: ['mundo', 'global', 'internacional', 'tierra'] },
    { name: 'Briefcase', component: Briefcase, color: 'text-blue-700', keywords: ['profesional', 'carrera', 'trabajo'] },
    { name: 'Users', component: Users, color: 'text-green-700', keywords: ['equipo', 'grupo', 'colaboración'] },
    { name: 'Heart', component: Heart, color: 'text-pink-700', keywords: ['cuidado', 'apoyo', 'solidaridad'] },
    { name: 'Target', component: Target, color: 'text-red-700', keywords: ['enfoque', 'dirección', 'propósito'] },
    { name: 'Zap', component: Zap, color: 'text-yellow-700', keywords: ['innovación', 'cambio', 'transformación'] }
  ];

  // Mock minkas where user is member (para elegir superminka) - will be fetched from dataService
  const [userMinkas, setUserMinkas] = useState([
    { id: 'argentina', nombre: 'ARGENTINA', miembros: 2000 },
    { id: 'pescadores', nombre: 'PESCADORES', miembros: 85 },
    { id: 'causas-populares', nombre: 'CAUSAS POPULARES', miembros: 320 }
  ]);

  // Navigation
  const goToNextStep = () => setCurrentStep(prev => prev + 1);
  const goToPrevStep = () => setCurrentStep(prev => prev - 1);
  const goToHome = () => router.push('/');

  // Skip step 2 if we have a parent context
  const shouldSkipStep2 = !!parentMinkaId;
  const totalSteps = shouldSkipStep2 ? 3 : 4;

  // Handle user search
  const handleUserSearch = async (query) => {
    try {
      const results = await dataService.searchUsers(query);
      const filteredResults = results.filter(user => 
        user.id !== '1' && !selectedUsers.find(selected => selected.id === user.id)
      );
      setUserSearchResults(filteredResults);
    } catch (error) {
      console.error('Error searching users:', error);
      setUserSearchResults([]);
    }
  };

  const handleUserSelect = (user) => {
    setSelectedUsers(prev => [...prev, user]);
    setUserSearchResults([]);
    if (errors.users) {
      setErrors(prev => ({ ...prev, users: '' }));
    }
  };

  const removeUser = (userId) => {
    setSelectedUsers(prev => prev.filter(user => user.id !== userId));
  };

  // Handle icon search
  const handleIconSearch = (query) => {
    setIconSearchQuery(query);
  };

  const getFilteredIcons = () => {
    if (!iconSearchQuery.trim()) return availableIcons;
    
    const searchLower = iconSearchQuery.toLowerCase();
    return availableIcons.filter(icon => 
      icon.name.toLowerCase().includes(searchLower) ||
      icon.keywords.some(keyword => keyword.includes(searchLower))
    );
  };

  // Handle minka search
  const handleMinkaSearch = (query) => {
    setMinkaSearchQuery(query);
  };

  const getFilteredMinkas = () => {
    if (!minkaSearchQuery.trim()) return userMinkas;
    
    const searchLower = minkaSearchQuery.toLowerCase();
    return userMinkas.filter(minka => 
      minka.nombre.toLowerCase().includes(searchLower)
    );
  };

  // Validate current step
  const validateStep = (step) => {
    const newErrors = {};
    
    if (step === 1) {
      if (!nombre.trim()) {
        newErrors.nombre = 'El nombre de la minka es requerido';
      } else if (nombre.length < 3) {
        newErrors.nombre = 'El nombre debe tener al menos 3 caracteres';
      }
      
      if (!descripcion.trim()) {
        newErrors.descripcion = 'La descripción es requerida';
      } else if (descripcion.length < 10) {
        newErrors.descripcion = 'La descripción debe tener al menos 10 caracteres';
      }
      
      if (!selectedIcon) {
        newErrors.icon = 'Debe seleccionar un ícono para la minka';
      }
    }
    
    if (step === 2 && !shouldSkipStep2) {
      if (!selectedParentMinka) {
        newErrors.parent = 'Debe seleccionar una superminka';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle form submission
  const handleSubmit = async () => {
    setIsSubmitting(true);
    
    try {
      const minkaData = {
        nombre,
        descripcion,
        icon: selectedIcon.name,
        iconColor: selectedIcon.color,
        parentMinkaId: parentMinkaId || selectedParentMinka?.id || null,
        creatorId: '1',
        invitedUserIds: selectedUsers.map(user => user.id),
        createdAt: new Date().toISOString()
      };
      
      const result = await dataService.createMinka(minkaData);
      console.log('Minka created:', result);
      setShowSuccess(true);
      
      setTimeout(() => {
        router.push('/');
      }, 3000);
      
    } catch (error) {
      console.error('Error creating minka:', error);
      setErrors({ submit: 'Error al crear la minka. Intenta nuevamente.' });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Auto-skip step 2 if needed
  const handleStep1Continue = () => {
    if (validateStep(1)) {
      if (shouldSkipStep2) {
        setCurrentStep(3); // Skip to step 3 (invites)
      } else {
        goToNextStep(); // Go to step 2 (parent selection)
      }
    }
  };

  // Success state
  if (showSuccess) {
    const IconComponent = selectedIcon?.component;
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <CheckCircle size={48} className="text-green-500 mx-auto mb-4" />
          <h2 className="text-xl font-bold text-gray-800 mb-2">¡Minka creada!</h2>
          <div className="flex items-center justify-center mb-4">
            {IconComponent && (
              <div className={`w-12 h-12 rounded-lg bg-gray-100 flex items-center justify-center mr-3`}>
                <IconComponent size={24} className={selectedIcon.color} />
              </div>
            )}
            <div>
              <p className="font-bold text-gray-800">{nombre}</p>
              <p className="text-sm text-gray-600">{descripcion}</p>
            </div>
          </div>
          <p className="text-sm text-gray-500">
            Se han enviado invitaciones a {selectedUsers.length} usuario{selectedUsers.length !== 1 ? 's' : ''}.
          </p>
        </Card>
      </div>
    );
  }

  // Step 1: Basic Info
  if (currentStep === 1) {
    return (
      <>
        <div className="m-4">
          <Card>
            <div className="p-5">
              <div className="flex items-center mb-3">
                <ChevronLeft 
                  size={24} 
                  onClick={goToHome}
                  className="cursor-pointer text-gray-600 mr-2"
                />
                <h1 className="text-xl font-bold text-gray-800">Información básica</h1>
              </div>
              <p className="text-gray-700 text-sm leading-relaxed">
                Definí el nombre, descripción e ícono de tu nueva minka (paso 1 de {totalSteps})
              </p>
            </div>
          </Card>
        </div>

        <div className="px-4 pb-6">
          <Card className="p-6">
            <div className="space-y-6">
              {/* Nombre */}
              <FormField
                label="Nombre de la minka"
                required
                error={errors.nombre}
              >
                <input
                  type="text"
                  value={nombre}
                  onChange={(e) => {
                    setNombre(e.target.value);
                    if (errors.nombre) setErrors(prev => ({ ...prev, nombre: '' }));
                  }}
                  placeholder="Ej: Desarrolladores Web, Amantes del Café, etc."
                  className={`w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent ${
                    errors.nombre ? 'border-red-500' : 'border-gray-300'
                  }`}
                />
              </FormField>

              {/* Descripción */}
              <FormField
                label="Descripción"
                required
                error={errors.descripcion}
                description="Explicá brevemente de qué se trata esta minka"
              >
                <textarea
                  value={descripcion}
                  onChange={(e) => {
                    setDescripcion(e.target.value);
                    if (errors.descripcion) setErrors(prev => ({ ...prev, descripcion: '' }));
                  }}
                  placeholder="Ej: Una comunidad para desarrolladores web que comparten conocimientos y proyectos"
                  rows={3}
                  className={`w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none ${
                    errors.descripcion ? 'border-red-500' : 'border-gray-300'
                  }`}
                />
              </FormField>

              {/* Ícono */}
              <FormField
                label="Ícono"
                required
                error={errors.icon}
                description="Buscá y seleccioná un ícono que represente tu minka"
              >
                <div className="space-y-3">
                  {/* Search input for icons */}
                  <div className="relative">
                    <input
                      type="text"
                      value={iconSearchQuery}
                      onChange={(e) => handleIconSearch(e.target.value)}
                      placeholder="Buscar ícono... (ej: música, trabajo, etc.)"
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    />
                  </div>
                  
                  {/* Selected icon preview */}
                  {selectedIcon && (
                    <div className="flex items-center p-3 bg-blue-50 border border-blue-200 rounded-lg">
                      <selectedIcon.component size={24} className={selectedIcon.color + " mr-3"} />
                      <span className="font-medium text-blue-800">Ícono seleccionado: {selectedIcon.name}</span>
                    </div>
                  )}
                  
                  {/* Icons grid */}
                  <div className="grid grid-cols-6 gap-2 max-h-48 overflow-y-auto border border-gray-200 rounded-lg p-3">
                    {getFilteredIcons().map((icon, index) => {
                      const IconComponent = icon.component;
                      const isSelected = selectedIcon?.name === icon.name && selectedIcon?.color === icon.color;
                      return (
                        <button
                          key={`${icon.name}-${icon.color}-${index}`}
                          type="button"
                          onClick={() => {
                            setSelectedIcon(icon);
                            if (errors.icon) setErrors(prev => ({ ...prev, icon: '' }));
                          }}
                          className={`w-12 h-12 rounded-lg border-2 flex items-center justify-center transition-all ${
                            isSelected 
                              ? 'border-blue-500 bg-blue-50' 
                              : 'border-gray-300 hover:border-gray-400 hover:bg-gray-50'
                          }`}
                          title={icon.name}
                        >
                          <IconComponent size={20} className={icon.color} />
                        </button>
                      );
                    })}
                  </div>
                  
                  {getFilteredIcons().length === 0 && iconSearchQuery && (
                    <p className="text-sm text-gray-500 text-center py-4">
                      No se encontraron íconos que coincidan con "{iconSearchQuery}"
                    </p>
                  )}
                </div>
              </FormField>

              <button
                onClick={handleStep1Continue}
                disabled={!nombre.trim() || !descripcion.trim() || !selectedIcon}
                className={`w-full py-3 px-4 rounded-lg font-medium text-white ${
                  !nombre.trim() || !descripcion.trim() || !selectedIcon
                    ? 'bg-gray-400 cursor-not-allowed' 
                    : 'bg-blue-600 hover:bg-blue-700'
                }`}
              >
                Continuar
              </button>
            </div>
          </Card>
        </div>
      </>
    );
  }

  // Step 2: Parent Minka (only if not coming from parent context)
  if (currentStep === 2 && !shouldSkipStep2) {
    return (
      <>
        <div className="m-4">
          <Card>
            <div className="p-5">
              <div className="flex items-center mb-3">
                <ChevronLeft 
                  size={24} 
                  onClick={goToPrevStep}
                  className="cursor-pointer text-gray-600 mr-2"
                />
                <h1 className="text-xl font-bold text-gray-800">Superminka</h1>
              </div>
              <p className="text-gray-700 text-sm leading-relaxed">
                ¿A qué minka más grande pertenecerá tu nueva minka? (paso 2 de {totalSteps})
              </p>
            </div>
          </Card>
        </div>

        <div className="px-4 pb-6">
          <Card className="p-6">
            <div className="space-y-4">
              <FormField
                label="Superminka (opcional)"
                description="Buscá una minka padre o dejá vacío para que sea independiente"
              >
                <div className="space-y-3">
                  {/* Search input for minkas */}
                  <div className="relative">
                    <input
                      type="text"
                      value={minkaSearchQuery}
                      onChange={(e) => handleMinkaSearch(e.target.value)}
                      placeholder="Buscar minka... o dejá vacío para minka independiente"
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    />
                  </div>
                  
                  {/* Selected parent preview */}
                  {selectedParentMinka && (
                    <div className="flex items-center justify-between p-3 bg-blue-50 border border-blue-200 rounded-lg">
                      <div>
                        <span className="font-medium text-blue-800">Superminka: {selectedParentMinka.nombre}</span>
                        <p className="text-sm text-blue-600">{selectedParentMinka.miembros.toLocaleString()} miembros</p>
                      </div>
                      <button
                        onClick={() => setSelectedParentMinka(null)}
                        className="text-blue-600 hover:text-blue-800"
                      >
                        <X size={16} />
                      </button>
                    </div>
                  )}
                  
                  {/* Option for no parent */}
                  {!selectedParentMinka && (
                    <div className="p-3 bg-gray-50 border border-gray-200 rounded-lg">
                      <p className="text-sm text-gray-600">
                        <strong>Minka independiente:</strong> No pertenecerá a ninguna superminka
                      </p>
                    </div>
                  )}
                  
                  {/* Minkas list */}
                  {minkaSearchQuery && (
                    <div className="border border-gray-200 rounded-lg max-h-48 overflow-y-auto">
                      {getFilteredMinkas().map((minka) => (
                        <button
                          key={minka.id}
                          onClick={() => {
                            setSelectedParentMinka(minka);
                            setMinkaSearchQuery('');
                          }}
                          className="w-full border-b border-gray-100 last:border-b-0 p-3 text-left hover:bg-gray-50 transition-all"
                        >
                          <div className="font-medium text-gray-800">{minka.nombre}</div>
                          <div className="text-sm text-gray-600">{minka.miembros.toLocaleString()} miembros</div>
                        </button>
                      ))}
                      
                      {getFilteredMinkas().length === 0 && (
                        <p className="text-sm text-gray-500 text-center py-4">
                          No se encontraron minkas que coincidan con "{minkaSearchQuery}"
                        </p>
                      )}
                    </div>
                  )}
                </div>
              </FormField>

              <button
                onClick={goToNextStep}
                className="w-full py-3 px-4 rounded-lg font-medium text-white bg-blue-600 hover:bg-blue-700"
              >
                Continuar {selectedParentMinka ? `(dentro de ${selectedParentMinka.nombre})` : '(minka independiente)'}
              </button>
            </div>
          </Card>
        </div>
      </>
    );
  }

  // Step 3: Invite Users
  const inviteStepNumber = shouldSkipStep2 ? 2 : 3;
  if (currentStep === 3 || (currentStep === 2 && shouldSkipStep2)) {
    return (
      <>
        <div className="m-4">
          <Card>
            <div className="p-5">
              <div className="flex items-center mb-3">
                <ChevronLeft 
                  size={24} 
                  onClick={goToPrevStep}
                  className="cursor-pointer text-gray-600 mr-2"
                />
                <h1 className="text-xl font-bold text-gray-800">Invitar miembros</h1>
              </div>
              <p className="text-gray-700 text-sm leading-relaxed">
                Invitá usuarios a unirse a tu nueva minka (paso {inviteStepNumber} de {totalSteps})
              </p>
            </div>
          </Card>
        </div>

        <div className="px-4 pb-6">
          <Card className="p-6">
            <FormField
              label="Miembros a invitar"
              description="Buscá y agregá usuarios que quieras invitar (opcional)"
            >
              <div className="space-y-3">
                {selectedUsers.length > 0 && (
                  <div className="flex flex-wrap gap-2 mb-3">
                    {selectedUsers.map(user => (
                      <div key={user.id} className="flex items-center bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm">
                        <span>{user.name}</span>
                        <button
                          type="button"
                          onClick={() => removeUser(user.id)}
                          className="ml-2 hover:bg-blue-200 rounded-full p-0.5"
                        >
                          <X size={14} />
                        </button>
                      </div>
                    ))}
                  </div>
                )}
                
                <SearchInput
                  placeholder="Buscar usuarios para invitar..."
                  onSearch={handleUserSearch}
                  suggestions={userSearchResults}
                  onSelect={handleUserSelect}
                  value=""
                  className="w-full"
                  renderSuggestion={(user) => (
                    <div className="flex items-center">
                      <div className="w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center mr-3">
                        <User size={16} className="text-gray-600" />
                      </div>
                      <div>
                        <div className="font-medium text-gray-800">{user.name}</div>
                        <div className="text-sm text-gray-500">@{user.username}</div>
                      </div>
                    </div>
                  )}
                />
              </div>
            </FormField>

            <button
              onClick={goToNextStep}
              className="w-full py-3 px-4 rounded-lg font-medium text-white bg-blue-600 hover:bg-blue-700"
            >
              Continuar ({selectedUsers.length} invitado{selectedUsers.length !== 1 ? 's' : ''})
            </button>
          </Card>
        </div>
      </>
    );
  }

  // Step 4: Confirmation
  const confirmStepNumber = shouldSkipStep2 ? 3 : 4;
  if (currentStep === 4 || (currentStep === 3 && shouldSkipStep2)) {
    const IconComponent = selectedIcon?.component;
    const parentMinka = parentMinkaId ? userMinkas.find(m => m.id === parentMinkaId) : selectedParentMinka;
    
    return (
      <>
        <div className="m-4">
          <Card>
            <div className="p-5">
              <div className="flex items-center mb-3">
                <ChevronLeft 
                  size={24} 
                  onClick={goToPrevStep}
                  className="cursor-pointer text-gray-600 mr-2"
                />
                <h1 className="text-xl font-bold text-gray-800">Confirmar creación</h1>
              </div>
              <p className="text-gray-700 text-sm leading-relaxed">
                Revisá los detalles de tu nueva minka (paso {confirmStepNumber} de {totalSteps})
              </p>
            </div>
          </Card>
        </div>

        <div className="px-4 pb-6">
          <Card className="p-6">
            <div className="space-y-6">
              {/* Minka Preview */}
              <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
                <h3 className="font-bold text-gray-800 mb-4">Tu nueva minka:</h3>
                <div className="flex items-start space-x-4">
                  {IconComponent && (
                    <div className="w-12 h-12 rounded-lg bg-white border border-gray-300 flex items-center justify-center">
                      <IconComponent size={24} className={selectedIcon.color} />
                    </div>
                  )}
                  <div className="flex-1">
                    <h4 className="font-bold text-gray-800 text-lg">{nombre}</h4>
                    <p className="text-gray-600 text-sm mt-1">{descripcion}</p>
                    {parentMinka ? (
                      <p className="text-xs text-gray-500 mt-2">
                        Dentro de: {parentMinka.nombre}
                      </p>
                    ) : (
                      <p className="text-xs text-gray-500 mt-2">
                        Minka independiente
                      </p>
                    )}
                  </div>
                </div>
              </div>

              {/* Invited Users */}
              {selectedUsers.length > 0 && (
                <div>
                  <h4 className="font-medium text-gray-800 mb-2">Usuarios invitados:</h4>
                  <div className="flex flex-wrap gap-2">
                    {selectedUsers.map(user => (
                      <div key={user.id} className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm">
                        {user.name}
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Submit Error */}
              {errors.submit && (
                <div className="p-3 bg-red-50 border border-red-200 rounded-lg flex items-center">
                  <AlertCircle size={18} className="text-red-500 mr-2" />
                  <span className="text-red-700 text-sm">{errors.submit}</span>
                </div>
              )}

              {/* Submit Button */}
              <button
                onClick={handleSubmit}
                disabled={isSubmitting}
                className={`w-full py-4 px-4 rounded-lg font-medium text-white ${
                  isSubmitting
                    ? 'bg-gray-400 cursor-not-allowed' 
                    : 'bg-green-600 hover:bg-green-700'
                }`}
              >
                {isSubmitting ? 'Creando minka...' : 'Crear minka'}
              </button>
            </div>
          </Card>
        </div>
      </>
    );
  }
}


//src/components/screens/DescribirAccionScreen.jsx

"use client";

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import { CheckCircle, AlertCircle } from 'lucide-react';
import Card from '@/components/ui/Card';
import FormField from '@/components/shared/FormField';
import MarkdownEditor from '@/components/shared/MarkdownEditor';
import { dataService } from '@/services/dataService';

export default function DescribirAccionScreen() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    nombre: '',
    resumen: '',
    detalles: ''
  });
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);

  const handleInputChange = (field, value) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
    
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: ''
      }));
    }
  };

  const validateForm = () => {
    const newErrors = {};

    if (!formData.nombre.trim()) {
      newErrors.nombre = 'El nombre de la acción es requerido';
    } else if (formData.nombre.length < 3) {
      newErrors.nombre = 'El nombre debe tener al menos 3 caracteres';
    }

    if (!formData.resumen.trim()) {
      newErrors.resumen = 'El resumen es requerido';
    } else if (formData.resumen.length < 10) {
      newErrors.resumen = 'El resumen debe tener al menos 10 caracteres';
    }

    if (!formData.detalles.trim()) {
      newErrors.detalles = 'Los detalles son requeridos';
    } else if (formData.detalles.length < 50) {
      newErrors.detalles = 'Los detalles deben tener al menos 50 caracteres';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);
    
    try {
      const savedAction = await dataService.saveAction(formData);
      console.log('Action saved:', savedAction);
      
      setShowSuccess(true);
      
      // Reset form after success
      setTimeout(() => {
        setFormData({ nombre: '', resumen: '', detalles: '' });
        setShowSuccess(false);
        router.push('/'); // Navigate back to home
      }, 2000);
      
    } catch (error) {
      console.error('Error saving action:', error);
      setErrors({ submit: 'Error al guardar la acción. Intenta nuevamente.' });
    } finally {
      setIsSubmitting(false);
    }
  };

  const defaultMarkdown = `# Descripción de la acción

## ¿En qué consiste?
Describí aquí los detalles de la acción...

## Requisitos o condiciones
- Requisito 1
- Requisito 2
- Requisito 3

## Evidencia requerida
Para demostrar que esta acción sucedió, se necesita:
- Tipo de evidencia 1 (ej: foto, documento, testigo)
- Tipo de evidencia 2
- Tipo de evidencia 3

## Consideraciones adicionales
Información adicional relevante...`;

  if (showSuccess) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <CheckCircle size={48} className="text-green-500 mx-auto mb-4" />
          <h2 className="text-xl font-bold text-gray-800 mb-2">¡Acción creada exitosamente!</h2>
          <p className="text-gray-600">
            La acción "{formData.nombre}" ha sido guardada y estará disponible para reportes.
          </p>
        </Card>
      </div>
    );
  }

  return (
    <>
      {/* Title Card */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <h1 className="text-xl font-bold text-gray-800 mb-3">Describir acción</h1>
            <p className="text-gray-700 text-sm leading-relaxed">
              Creá una nueva acción que podrá ser reportada y validada por la comunidad.
            </p>
          </div>
        </Card>
      </div>

      {/* Form */}
      <div className="px-4 pb-6">
        <Card className="p-6">
          <form onSubmit={handleSubmit}>
            {/* Action Name */}
            <FormField
              label="Nombre de la acción"
              required
              error={errors.nombre}
            >
              <input
                type="text"
                value={formData.nombre}
                onChange={(e) => handleInputChange('nombre', e.target.value)}
                placeholder="Ejemplo: Pescar trucha bebé"
                className={`w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent ${
                  errors.nombre ? 'border-red-500' : 'border-gray-300'
                }`}
              />
            </FormField>

            {/* Action Summary */}
            <FormField
              label="Resumen de la acción"
              required
              error={errors.resumen}
              description="Describí brevemente en qué consiste la acción"
            >
              <textarea
                value={formData.resumen}
                onChange={(e) => handleInputChange('resumen', e.target.value)}
                placeholder="Ejemplo: Romper la sustentabilidad pescando truchas de menos de 5 cm de largo"
                rows={3}
                className={`w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none ${
                  errors.resumen ? 'border-red-500' : 'border-gray-300'
                }`}
              />
            </FormField>

            {/* Details Description */}
            <div className="mb-4">
              <h3 className="text-sm font-medium text-gray-700 mb-2">
                Detallá tu acción
              </h3>
              <p className="text-sm text-gray-600 mb-4">
                Describí de qué se trata la acción lo más precisamente que puedas, y caracterizá bien la evidencia que hace falta para demostrar que la acción sucedió.
              </p>
            </div>

            {/* Markdown Editor */}
            <FormField
              label="Detalles"
              required
              error={errors.detalles}
            >
              <div className={`border rounded-lg ${errors.detalles ? 'border-red-500' : 'border-gray-300'}`}>
                <MarkdownEditor
                  value={formData.detalles || defaultMarkdown}
                  onChange={(value) => handleInputChange('detalles', value || '')}
                  placeholder="Describí los detalles de la acción usando markdown..."
                  height={300}
                />
              </div>
              <p className="text-xs text-gray-500 mt-2">
                Podés usar markdown para formatear el texto (títulos, listas, negritas, etc.)
              </p>
            </FormField>

            {/* Submit Error */}
            {errors.submit && (
              <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg flex items-center">
                <AlertCircle size={18} className="text-red-500 mr-2" />
                <span className="text-red-700 text-sm">{errors.submit}</span>
              </div>
            )}

            {/* Submit Button */}
            <div className="flex gap-3">
              <button
                type="button"
                onClick={() => router.back()}
                className="flex-1 py-3 px-4 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 font-medium"
              >
                Cancelar
              </button>
              <button
                type="submit"
                disabled={isSubmitting}
                className={`flex-1 py-3 px-4 rounded-lg font-medium text-white ${
                  isSubmitting 
                    ? 'bg-gray-400 cursor-not-allowed' 
                    : 'bg-blue-600 hover:bg-blue-700'
                }`}
              >
                {isSubmitting ? 'Guardando...' : 'Crear acción'}
              </button>
            </div>
          </form>
        </Card>
      </div>
    </>
  );
}


//src/components/screens/EmprenderViajeScreen.jsx

"use client";

import React from 'react';
import { Fish, MapPin, ShoppingBag, Baby } from 'lucide-react';
import Card from '@/components/ui/Card';
import SectionTitle from '@/components/ui/SectionTitle';
import ActionRow from '@/components/ui/ActionRow';
import CaseItem from '@/components/ui/CaseItem';
import ValuationChart from '@/components/ui/ValuationChart';

export default function EmprenderViajeScreen() {
  return (
    <>
      {/* Action Description Card */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <h1 className="text-xl font-bold text-gray-800 mb-3">Emprender viaje</h1>
            <p className="text-gray-700 text-sm leading-relaxed">
              Salir de pesca con barco mediano a mar abierto.
            </p>
          </div>
        </Card>
      </div>

      {/* Applies To Section */}
      <div className="px-4 pb-4">
        <Card>
          <div className="p-4 flex items-center">
            <div className="w-6 h-6 rounded bg-gray-100 flex items-center justify-center mr-3">
              <Fish size={16} className="text-blue-700" />
            </div>
            <span className="text-gray-800 font-medium">Aplica a Pescadores</span>
          </div>
        </Card>
      </div>

      {/* Current Valuation */}
      <div className="px-4 pb-4">
        <Card className="p-4">
          <ValuationChart 
            title="Valoración actual"
            currentValue="+₭12"
            avgValue="+₭10"
            totalImpact="+₭500"
            showValuationInfo={true}
            actionId="emprender-viaje"
          />
        </Card>
      </div>

      {/* Time-based Valuation */}
      <div className="px-4 pb-4">
        <Card className="p-4">
          <ValuationChart 
            title="Valoración en el tiempo"
            showTimeChart={true}
            showValuationInfo={false}
          />
        </Card>
      </div>

      {/* Recent Cases Section */}
      <SectionTitle 
        title="Últimos casos" 
        actionText="Ver todos" 
        onAction={() => console.log('Ver todos casos')} 
      />

      <div className="px-4 pb-4">
        <Card>
          <CaseItem 
            name="Juan"
            time="11:36"
            date="10/2/2025"
            value="₭300"
            isPositive={true}
          />
          <CaseItem 
            name="Vanna"
            time="10:02"
            date="11/1/2025"
            value="₭200"
            isPositive={true}
          />
          <CaseItem 
            name="Juan"
            time="10:00"
            date="25/02/2023"
            value="₭10"
            isPositive={true}
          />
        </Card>
      </div>

      {/* Details Section */}
      <SectionTitle title="Detalles" />

      <div className="px-4 pb-6">
        <Card>
          <div className="p-5">
            <div className="mb-4">
              <h4 className="font-medium text-gray-800 mb-2">Ubicación</h4>
              <ul className="text-sm text-gray-700 space-y-1 ml-4">
                <li className="flex items-start">
                  <span className="inline-block w-1 h-1 bg-gray-400 rounded-full mt-2 mr-2 flex-shrink-0"></span>
                  Salir de Puerto Alegro o Río de La Plata.
                </li>
                <li className="flex items-start">
                  <span className="inline-block w-1 h-1 bg-gray-400 rounded-full mt-2 mr-2 flex-shrink-0"></span>
                  Embarcación pesquera de más de 8 metros.
                </li>
                <li className="flex items-start">
                  <span className="inline-block w-1 h-1 bg-gray-400 rounded-full mt-2 mr-2 flex-shrink-0"></span>
                  Tripulación de 8 pescadores con experiencia.
                </li>
              </ul>
            </div>
            
            <div>
              <h4 className="font-medium text-gray-800 mb-2">Consideraciones</h4>
              <ul className="text-sm text-gray-700 space-y-1 ml-4">
                <li className="flex items-start">
                  <span className="inline-block w-1 h-1 bg-gray-400 rounded-full mt-2 mr-2 flex-shrink-0"></span>
                  Respetar las zonas de pesca autorizadas.
                </li>
              </ul>
            </div>
          </div>
        </Card>
      </div>
    </>
  );
}


//src/components/screens/HomeScreen.jsx

// src/components/screens/HomeScreen.jsx - Updated version
"use client";

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { 
  TrendingUp, 
  FileText, 
  Clock, 
  Search, 
  PlusCircle, 
  ArrowDownCircle, 
  ArrowUpCircle,
  Fish, 
  Megaphone, 
  Gavel,
  Eye,
  EyeOff,
  ArrowUp,
  ArrowRight,
  ArrowDown,
  ArrowLeftRight,
  Users,
  Globe,
  Heart,
  // Import more icons as needed
} from 'lucide-react';
import Card from '@/components/ui/Card';
import ActionButton from '@/components/ui/ActionButton';
import ActionItem from '@/components/ui/ActionItem';
import SectionTitle from '@/components/ui/SectionTitle';
import ListItem from '@/components/ui/ListItem';
import { theme } from '@/styles/theme';
import { dataService } from '@/services/dataService';

// Icon mapping
const iconMap = {
  Fish: Fish,
  Users: Users,
  Globe: Globe,
  Heart: Heart,
  // Add more mappings as needed
};

export default function HomeScreen() {
  const [isBalanceVisible, setIsBalanceVisible] = useState(true);
  const [userData, setUserData] = useState(null);
  const [userMinkas, setUserMinkas] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const router = useRouter();
  
  useEffect(() => {
    loadUserData();
  }, []);
  
  const loadUserData = async () => {
    try {
      const [user, minkas] = await Promise.all([
        dataService.getCurrentUser(),
        dataService.getUserMinkas('1') // Current user ID
      ]);
      
      setUserData(user);
      setUserMinkas(organizeMinkasHierarchy(minkas));
    } catch (error) {
      console.error('Error loading user data:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Organize minkas in hierarchy for display
  const organizeMinkasHierarchy = (minkas) => {
    const organized = [];
    const minkaMap = {};
    
    // Create map
    minkas.forEach(minka => {
      minkaMap[minka.id] = { ...minka, children: [] };
    });
    
    // Build hierarchy
    minkas.forEach(minka => {
      if (!minka.parentId) {
        organized.push(minkaMap[minka.id]);
      } else if (minkaMap[minka.parentId]) {
        minkaMap[minka.parentId].children.push(minkaMap[minka.id]);
      }
    });
    
    return organized;
  };
  
  // Calculate total balance
  const calculateTotalBalance = () => {
    return userMinkas.reduce((total, minka) => {
      const minkaBalance = parseFloat(minka.balance.replace('₭', '').trim());
      const childrenBalance = minka.children.reduce((childTotal, child) => {
        return childTotal + parseFloat(child.balance.replace('₭', '').trim());
      }, 0);
      return total + minkaBalance + childrenBalance;
    }, 0);
  };
  
  const toggleBalanceVisibility = () => {
    setIsBalanceVisible(!isBalanceVisible);
  };
  
  const renderMinkaItem = (minka, indentLevel = 0) => {
    const MinkaIcon = iconMap[minka.icon] || Users;
    const items = [];
    
    // Add the minka itself
    items.push(
      <ListItem 
        key={minka.id}
        icon={
          <div className="w-10 h-10 rounded-lg bg-blue-50 flex items-center justify-center">
            <MinkaIcon size={22} className={minka.iconColor} />
          </div>
        }
        title={minka.name}
        subtitle={`${minka.members} miembros`}
        value={minka.balance}
        isPositive={minka.isPositive}
        indentLevel={indentLevel}
        minkaId={minka.id}
        onClick={() => router.push(`/minka/${minka.id}`)}
      />
    );
    
    // Add children
    if (minka.children && minka.children.length > 0) {
      minka.children.forEach(child => {
        items.push(...renderMinkaItem(child, indentLevel + 1));
      });
    }
    
    return items;
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  return (
    <>
      {/* Account Overview Card */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <div className="flex justify-between items-start mb-4">
              <div className="text-gray-500 text-sm">Cuenta: {userData?.username}</div>
              <div 
                className="text-sm text-blue-600 cursor-pointer"
                onClick={() => router.push('/mis-movimientos')}
              >
                Ver mis movimientos &gt;
              </div>
            </div>
            
            <div className="flex items-baseline mb-4">
              {isBalanceVisible ? (
                <>
                  <span className="text-3xl font-bold mr-1">
                    ₭ {userData?.balance.toLocaleString('es-AR')}
                  </span>
                  <span className="text-lg text-gray-500 self-start">
                    {(userData?.balance % 1).toFixed(2).substring(2)}
                  </span>
                </>
              ) : (
                <span className="text-3xl font-bold">₭ ••••••</span>
              )}
              <button 
                onClick={toggleBalanceVisibility}
                className="ml-2 text-gray-400 hover:text-gray-600 self-baseline"
              >
                {isBalanceVisible ? <Eye size={20} /> : <EyeOff size={20} />}
              </button>
            </div>
            
            <div className="flex justify-center items-center text-xs">
              <ArrowUpCircle size={14} className="text-green-500 mr-1" />
              <div className="text-green-600 font-medium">₭ {userData?.lastChange || 0}</div>
              <div className="ml-1 text-gray-500">desde la última vez</div>
            </div>
          </div>
        </Card>
      </div>

      {/* Primary Actions */}
      <div className="grid grid-cols-4 px-4 pb-6 text-center text-xs gap-4">
        <ActionButton 
          icon={<ArrowUp size={24} className="text-green-600" />} 
          label="Depositar"
          bgColor={theme.colors.success.light}
        />
        <ActionButton 
          icon={<ArrowRight size={24} className="text-blue-600" />} 
          label="Transferir"
          bgColor={theme.colors.primary.light}
          onClick={() => router.push('/transferir')}
        />
        <ActionButton 
          icon={<ArrowLeftRight size={24} className="text-purple-600" />} 
          label="Pactar"
          bgColor={theme.colors.secondary.light}
          onClick={() => router.push('/pactar')}
        />
        <ActionButton 
          icon={<ArrowDown size={24} className="text-red-600" />} 
          label="Extraer"
          bgColor={theme.colors.danger.light}
        />
      </div>

      {/* Secondary Actions Cards */}
      <div className="px-4 pb-6">
        <Card className="p-4 mb-4">
          <h3 className="text-sm font-medium text-gray-700 mb-3">Acciones</h3>
          <div className="grid grid-cols-2 gap-4">
            <ActionItem 
              icon={<Megaphone size={20} className="text-gray-700" />}
              label="Reportar acto"
              onClick={() => router.push('/reportar-acto')}
            />
            <ActionItem 
              icon={<Gavel size={20} className="text-gray-700" />}
              label="Validar acto"
              onClick={() => router.push('/validar-acto')}
            />
            <ActionItem 
              icon={<FileText size={20} className="text-gray-700" />}
              label="Describir acción"
              onClick={() => router.push('/describir-accion')}
            />
            <ActionItem 
              icon={<Clock size={20} className="text-gray-700" />}
              label="Historial"
            />
          </div>
        </Card>
        
        <Card className="p-4">
          <h3 className="text-sm font-medium text-gray-700 mb-3">Minkas</h3>
          <div className="grid grid-cols-2 gap-4">
            <ActionItem 
              icon={<Search size={20} className="text-gray-700" />}
              label="Buscar Minkas"
            />
            <ActionItem 
              icon={<PlusCircle size={20} className="text-blue-700" />}
              label="Nueva Minka"
              highlight={true}
              onClick={() => router.push('/crear-minka')}
            />
          </div>
        </Card>
      </div>

      {/* Section Title */}
      <SectionTitle 
        title="MIS MINKAS" 
        actionText="Ver todas" 
        onAction={() => console.log('Ver todas clicked')} 
      />

      {/* Minka List in Card */}
      <div className="px-4 pb-6">
        <Card>
          {/* Render hierarchical minkas */}
          {userMinkas.map(minka => renderMinkaItem(minka))}
          
          {/* Total */}
          <ListItem 
            title="TOTAL"
            value={`₭ ${calculateTotalBalance().toFixed(0)}`}
            isPositive={true}
            isTotal={true}
          />
        </Card>
      </div>
    </>
  );
}




//src/components/screens/MinkaDetailScreen.jsx

"use client";

import React from 'react';
import { useRouter } from 'next/navigation';
import { 
  LogOut,
  UserPlus,
  Plus,
  // Dynamic icon imports based on icon name
  Fish,
  Users,
  Globe,
  MapPin,
  ShoppingBag,
  Baby
} from 'lucide-react';
import Card from '@/components/ui/Card';
import ActionItem from '@/components/ui/ActionItem';
import SectionTitle from '@/components/ui/SectionTitle';
import ActionRow from '@/components/ui/ActionRow';
import MinkaListItem from '@/components/ui/MinkaListItem';

// Icon mapping helper
const iconMap = {
  Fish: Fish,
  Users: Users,
  Globe: Globe,
  MapPin: MapPin,
  ShoppingBag: ShoppingBag,
  Baby: Baby,
  // Add more icons as needed
};

export default function MinkaDetailScreen({ minka, actions, subMinkas }) {
  const router = useRouter();
  
  const MinkaIcon = iconMap[minka.icon] || Fish;
  
  const handleCreateSubminka = () => {
    router.push(`/crear-minka?parent=${minka.id}`);
  };
  
  const handleInviteMember = () => {
    // TODO: Implement invite functionality
    console.log('Invite member to', minka.id);
  };
  
  const handleLeaveMinka = () => {
    // TODO: Implement leave functionality
    console.log('Leave minka', minka.id);
  };

  const handleViewAllActions = () => {
    router.push(`/minka/${minka.id}/valuations`);
  };

  return (
    <>
      {/* Minka Title Card */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <div className="flex items-center mb-3">
              <div className="w-12 h-12 rounded-lg bg-blue-50 flex items-center justify-center mr-4">
                <MinkaIcon size={28} className={minka.iconColor} />
              </div>
              <div>
                <h1 className="text-2xl font-bold text-gray-800">{minka.name}</h1>
              </div>
            </div>
            <p className="text-gray-700 text-sm leading-relaxed">
              {minka.description}
            </p>
          </div>
        </Card>
      </div>

      {/* Participation Section */}
      <div className="px-4 pb-4">
        <Card className="p-4">
          <h3 className="text-sm font-medium text-gray-700 mb-3">Participación</h3>
          <div className="grid grid-cols-2 gap-4">
            <ActionItem 
              icon={<LogOut size={20} className="text-gray-700" />}
              label="Abandonar minka"
              onClick={handleLeaveMinka}
            />
            <ActionItem 
              icon={<UserPlus size={20} className="text-blue-700" />}
              label="Invitar miembro"
              highlight={true}
              onClick={handleInviteMember}
            />
          </div>
        </Card>
      </div>

      {/* Valued Actions Section */}
      {actions && actions.length > 0 && (
        <>
          <SectionTitle 
            title="Acciones valoradas" 
            actionText="Ver todas" 
            onAction={handleViewAllActions} 
          />

          <div className="px-4 pb-4">
            <Card>
              {actions.slice(0, 3).map((actionWithValuation, index) => (
                <ActionRow 
                  key={actionWithValuation.id || index}
                  action={actionWithValuation}
                  valuation={actionWithValuation.valuation}
                  minkaContext={minka}
                />
              ))}
            </Card>
          </div>

          <div className="px-4 pb-4">
            <button 
              onClick={handleViewAllActions}
              className="w-full py-3 px-4 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 font-medium border border-gray-300"
            >
              Ver todas las acciones valoradas por {minka.name.toLowerCase()}
            </button>
          </div>
        </>
      )}

      {/* No Actions Message */}
      {(!actions || actions.length === 0) && (
        <>
          <SectionTitle 
            title="Acciones valoradas" 
            actionText="Crear primera" 
            onAction={() => router.push(`/valorar-nueva-accion?minka=${minka.id}`)} 
          />

          <div className="px-4 pb-4">
            <Card className="p-6 text-center">
              <h3 className="font-medium text-gray-800 mb-2">No hay acciones valoradas</h3>
              <p className="text-gray-600 text-sm mb-4">
                {minka.name} aún no ha valorado ninguna acción.
              </p>
              <button 
                onClick={() => router.push(`/valorar-nueva-accion?minka=${minka.id}`)}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
              >
                Valorar primera acción
              </button>
            </Card>
          </div>
        </>
      )}

      {/* Sub-Minkas Section */}
      {subMinkas && subMinkas.length > 0 && (
        <>
          <SectionTitle 
            title={`Minkas en ${minka.name}`} 
            actionText="Ver todas"
            onAction={() => console.log('Ver todas las minkas')}
          />

          <div className="px-4 pb-4">
            <Card>
              {subMinkas.map((subMinka) => {
                const SubMinkaIcon = iconMap[subMinka.icon] || Fish;
                
                return (
                  <MinkaListItem 
                    key={subMinka.id}
                    icon={
                      <div className="w-10 h-10 rounded-lg bg-blue-50 flex items-center justify-center">
                        <SubMinkaIcon size={20} className={subMinka.iconColor} />
                      </div>
                    }
                    title={subMinka.name}
                    subtitle={`${subMinka.members} miembros`}
                    value={subMinka.balance}
                    isPositive={subMinka.isPositive}
                    isMember={true} // TODO: Check actual membership
                    onClick={() => router.push(`/minka/${subMinka.id}`)}
                  />
                );
              })}
              
              {/* Create new subminka button */}
              <div 
                className="p-4 border-t border-gray-100 flex items-center justify-center hover:bg-gray-50 cursor-pointer"
                onClick={handleCreateSubminka}
              >
                <Plus size={20} className="text-blue-600 mr-2" />
                <span className="text-blue-600 font-medium">Crear nueva minka en {minka.name}</span>
              </div>
            </Card>
          </div>

          <div className="px-4 pb-6">
            <button 
              onClick={() => console.log('Ver todas las minkas')}
              className="w-full py-3 px-4 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 font-medium border border-gray-300"
            >
              Ver todas las minkas en {minka.name.toLowerCase()}
            </button>
          </div>
        </>
      )}

      {/* Create Sub-Minka Section - Always show if no sub-minkas */}
      {(!subMinkas || subMinkas.length === 0) && (
        <div className="px-4 pb-6">
          <Card className="p-6 text-center">
            <h3 className="font-medium text-gray-800 mb-2">Crear primera sub-minka</h3>
            <p className="text-gray-600 text-sm mb-4">
              Podés crear minkas más específicas dentro de {minka.name}.
            </p>
            <button 
              onClick={handleCreateSubminka}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              Crear sub-minka
            </button>
          </Card>
        </div>
      )}
    </>
  );
}


//src/components/screens/MinkaValuationsScreen.jsx

"use client";

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Plus, Fish, Users, Globe, Heart, Code, Car } from 'lucide-react';
import Card from '@/components/ui/Card';
import ActionRow from '@/components/ui/ActionRow';
import { dataService } from '@/services/dataService';

// Icon mapping
const iconMap = {
  Fish,
  Users,
  Globe,
  Heart,
  Code,
  Car,
  // Add more as needed
};

export default function MinkaValuationsScreen({ minkaId }) {
  const router = useRouter();
  
  const [minka, setMinka] = useState(null);
  const [actionsWithValuations, setActionsWithValuations] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (minkaId) {
      loadMinkaData();
    } else {
      setError('No minka ID provided');
      setIsLoading(false);
    }
  }, [minkaId]);

  const loadMinkaData = async () => {
    try {
      const minkaData = await dataService.getMinka(minkaId);
      
      if (!minkaData) {
        setError(`Minka '${minkaId}' not found`);
        return;
      }
      
      const valuationsData = await dataService.getActionsWithValuations(minkaId);
      
      setMinka(minkaData);
      setActionsWithValuations(valuationsData || []);
      setError(null);
    } catch (error) {
      console.error('Error loading minka valuations:', error);
      setError(`Error loading data: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const handleCreateNewValuation = () => {
    router.push(`/valorar-nueva-accion?minka=${minkaId}`);
  };

  if (isLoading) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-gray-600">Cargando valoraciones...</p>
          <p className="text-xs text-gray-500 mt-2">Minka ID: {minkaId || 'undefined'}</p>
        </Card>
      </div>
    );
  }

  if (error) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <h2 className="text-xl font-bold text-gray-800 mb-2">Error</h2>
          <p className="text-gray-600 mb-4">{error}</p>
          <button
            onClick={() => router.back()}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Volver
          </button>
        </Card>
      </div>
    );
  }

  if (!minka) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <h2 className="text-xl font-bold text-gray-800 mb-2">Minka no encontrada</h2>
          <p className="text-gray-600 mb-4">La minka '{minkaId}' no existe.</p>
          <button
            onClick={() => router.back()}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Volver
          </button>
        </Card>
      </div>
    );
  }

  const MinkaIcon = iconMap[minka.icon] || iconMap.Users;

  return (
    <>
      {/* Title Card */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <div className="flex items-center mb-3">
              <div className="w-12 h-12 rounded-lg bg-blue-50 flex items-center justify-center mr-4">
                <MinkaIcon size={28} className={minka.iconColor || 'text-blue-600'} />
              </div>
              <div>
                <h1 className="text-2xl font-bold text-gray-800">Acciones valoradas</h1>
                <p className="text-gray-600">por {minka.name}</p>
              </div>
            </div>
            <p className="text-gray-700 text-sm leading-relaxed">
              Todas las acciones que {minka.name.toLowerCase()} ha valorado con karma.
            </p>
          </div>
        </Card>
      </div>

      {/* Create New Valuation Button */}
      <div className="px-4 pb-4">
        <button
          onClick={handleCreateNewValuation}
          className="w-full py-3 px-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium flex items-center justify-center"
        >
          <Plus size={20} className="mr-2" />
          Valorar nueva acción para {minka.name}
        </button>
      </div>

      {/* Valuations List */}
      <div className="px-4 pb-6">
        {actionsWithValuations.length === 0 ? (
          <Card className="p-6 text-center">
            <h3 className="text-lg font-medium text-gray-800 mb-2">No hay valoraciones</h3>
            <p className="text-gray-600 mb-4">
              {minka.name} aún no ha valorado ninguna acción.
            </p>
            <button
              onClick={handleCreateNewValuation}
              className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              Crear primera valoración
            </button>
          </Card>
        ) : (
          <Card>
            {actionsWithValuations.map((actionWithValuation, index) => (
              <ActionRow 
                key={actionWithValuation.id || index}
                action={actionWithValuation}
                valuation={actionWithValuation.valuation}
                minkaContext={minka}
              />
            ))}
          </Card>
        )}
      </div>

      {/* Footer Note */}
      {actionsWithValuations.length > 0 && (
        <div className="px-4 pb-6">
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <p className="text-blue-800 text-sm">
              <strong>Nota:</strong> Estas valoraciones se aplican cuando alguien realiza estas acciones. 
              Los miembros de {minka.name} contribuyen con el karma especificado.
            </p>
          </div>
        </div>
      )}
    </>
  );
}


//src/components/screens/MisMovimientosScreen.jsx

// src/components/screens/MisMovimientosScreen.jsx
"use client";

import React, { useState, useEffect } from 'react';
import { Fish, Car, Globe, User, Factory, Users, Heart, Leaf, Code, Briefcase } from 'lucide-react';
import Card from '@/components/ui/Card';
import MovementItem from '@/components/ui/MovementItem';
import { dataService } from '@/services/dataService';

// Icon mapping for different scopes
const iconMap = {
  Fish: Fish,
  Car: Car,
  Globe: Globe,
  User: User,
  Factory: Factory,
  Users: Users,
  Heart: Heart,
  Leaf: Leaf,
  Code: Code,
  Briefcase: Briefcase
};

export default function MisMovimientosScreen() {
  const [movements, setMovements] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadMovements();
  }, []);

  const loadMovements = async () => {
    try {
      // Get movements for current user (hardcoded as '1' for Juan)
      const userMovements = await dataService.getUserMovements('1');
      setMovements(userMovements);
    } catch (error) {
      console.error('Error loading movements:', error);
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  return (
    <>
      {/* Title */}
      <div className="px-4 py-6">
        <h1 className="text-2xl font-bold text-gray-800">Mis movimientos</h1>
      </div>

      {/* Movements List */}
      <div className="px-4 pb-6">
        <div className="space-y-0">
          {movements.length === 0 ? (
            <Card className="p-6 text-center">
              <p className="text-gray-600">No hay movimientos registrados</p>
            </Card>
          ) : (
            movements.map((movement) => {
              const ScopeIcon = iconMap[movement.scopeIcon] || User;
              
              return (
                <MovementItem 
                  key={movement.id}
                  transactionText={movement.text}
                  amount={movement.amount.toString()}
                  isPositive={movement.isPositive}
                  scopeIcon={<ScopeIcon size={14} className={getScopeIconColor(movement.scopeIcon)} />}
                  scopeLabel={movement.scopeLabel}
                  scopePosition="left"
                  percentage={movement.reason}
                  alignment={movement.alignment}
                  timestamp={movement.timestamp}
                />
              );
            })
          )}
        </div>
      </div>
    </>
  );
}

// Helper function to get icon color based on scope
function getScopeIconColor(iconName) {
  const colorMap = {
    Fish: 'text-blue-600',
    Car: 'text-gray-600',
    Globe: 'text-green-600',
    User: 'text-gray-600',
    Factory: 'text-purple-600',
    Users: 'text-purple-600',
    Heart: 'text-red-600',
    Leaf: 'text-green-600',
    Code: 'text-emerald-600',
    Briefcase: 'text-gray-600'
  };
  
  return colorMap[iconName] || 'text-gray-600';
}


//src/components/screens/PactarScreen.jsx

"use client";

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import { CheckCircle, AlertCircle, Users, FileText, ArrowRight, ArrowLeft, Percent, User, X, ChevronLeft, ChevronsLeftRight, ChevronsRightLeft } from 'lucide-react';
import Card from '@/components/ui/Card';
import FormField from '@/components/shared/FormField';
import SearchInput from '@/components/shared/SearchInput';
import { dataService } from '@/services/dataService';

export default function PactarScreen() {
  const router = useRouter();
  
  // Form data
  const [selectedAction, setSelectedAction] = useState(null);
  const [selectedUsers, setSelectedUsers] = useState([]);
  const [transferDirection, setTransferDirection] = useState('');
  const [transferType, setTransferType] = useState('percentage');
  const [transferAmount, setTransferAmount] = useState('');
  
  // UI state
  const [currentStep, setCurrentStep] = useState(1);
  const [actionSearchResults, setActionSearchResults] = useState([]);
  const [userSearchResults, setUserSearchResults] = useState([]);
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);

  // Navigation
  const goToNextStep = () => setCurrentStep(prev => prev + 1);
  const goToPrevStep = () => setCurrentStep(prev => prev - 1);
  const goToHome = () => router.push('/');

  // Handle action search
  const handleActionSearch = async (query) => {
    try {
      const results = await dataService.searchActions(query);
      setActionSearchResults(results);
    } catch (error) {
      console.error('Error searching actions:', error);
      setActionSearchResults([]);
    }
  };

  const handleActionSelect = (action) => {
    setSelectedAction(action);
    setActionSearchResults([]);
    goToNextStep(); // Auto-advance to step 3
  };

  // Handle user search
  const handleUserSearch = async (query) => {
    try {
      const results = await dataService.searchUsers(query);
      const filteredResults = results.filter(user => 
        user.id !== '1' && !selectedUsers.find(selected => selected.id === user.id)
      );
      setUserSearchResults(filteredResults);
    } catch (error) {
      console.error('Error searching users:', error);
      setUserSearchResults([]);
    }
  };

  const handleUserSelect = (user) => {
    setSelectedUsers(prev => [...prev, user]);
    setUserSearchResults([]);
    setErrors(prev => ({ ...prev, users: '' }));
  };

  const removeUser = (userId) => {
    setSelectedUsers(prev => prev.filter(user => user.id !== userId));
  };

  // Handle direction selection
  const handleDirectionSelect = (direction) => {
    setTransferDirection(direction);
    goToNextStep(); // Auto-advance to step 4
  };

  // Handle form changes
  const handleTransferAmountChange = (value) => {
    setTransferAmount(value);
    if (errors.amount) {
      setErrors(prev => ({ ...prev, amount: '' }));
    }
  };

  // Validate current step
  const validateStep = (step) => {
    const newErrors = {};
    
    if (step === 1 && selectedUsers.length === 0) {
      newErrors.users = 'Debe invitar al menos un usuario al pacto';
    }
    
    if (step === 4) {
      if (!transferAmount.trim()) {
        newErrors.amount = 'Debe especificar la cantidad de la transferencia';
      } else {
        const numValue = parseFloat(transferAmount);
        if (isNaN(numValue) || numValue <= 0) {
          newErrors.amount = 'La cantidad debe ser un número positivo';
        } else if (transferType === 'percentage' && numValue > 100) {
          newErrors.amount = 'El porcentaje no puede ser mayor a 100%';
        } else if (transferType === 'fixed' && numValue > 10000) {
          newErrors.amount = 'La cantidad fija no puede ser mayor a ₭10,000';
        }
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle form submission
  const handleSubmit = async () => {
    if (!validateStep(4)) return;

    setIsSubmitting(true);
    
    try {
      const pactData = {
        actionId: selectedAction.id,
        creatorId: '1',
        participantIds: selectedUsers.map(user => user.id),
        transferDirection,
        transferType,
        transferAmount: parseFloat(transferAmount),
        createdAt: new Date().toISOString()
      };
      
      const result = await dataService.createPact(pactData);
      console.log('Pact created:', result);
      setShowSuccess(true);
      
      setTimeout(() => {
        router.push('/');
      }, 3000);
      
    } catch (error) {
      console.error('Error creating pact:', error);
      setErrors({ submit: 'Error al crear el pacto. Intenta nuevamente.' });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Success state
  if (showSuccess) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <CheckCircle size={48} className="text-green-500 mx-auto mb-4" />
          <h2 className="text-xl font-bold text-gray-800 mb-2">¡Pacto propuesto!</h2>
          <p className="text-gray-600 mb-4">
            Se ha enviado la propuesta de pacto para <strong>"{selectedAction?.name}"</strong> a {selectedUsers.length} usuario{selectedUsers.length > 1 ? 's' : ''}.
          </p>
          <p className="text-sm text-gray-500">
            Los participantes recibirán una notificación para aceptar o rechazar el pacto.
          </p>
        </Card>
      </div>
    );
  }

  // Step 1: Choose participants
  if (currentStep === 1) {
    return (
      <>
        <div className="m-4">
          <Card>
            <div className="p-5">
              <div className="flex items-center mb-3">
                <ChevronLeft 
                  size={24} 
                  onClick={goToHome}
                  className="cursor-pointer text-gray-600 mr-2"
                />
                <h1 className="text-xl font-bold text-gray-800">Elegir participantes</h1>
              </div>
              <p className="text-gray-700 text-sm leading-relaxed">
                Invitá a otros usuarios a formar parte de este pacto (paso 1 de 5)
              </p>
            </div>
          </Card>
        </div>

        <div className="px-4 pb-6">
          <Card className="p-6">
            <FormField
              label="Participantes del pacto"
              required
              error={errors.users}
              description="Buscá y agregá usuarios al pacto"
            >
              <div className="space-y-3">
                {selectedUsers.length > 0 && (
                  <div className="flex flex-wrap gap-2 mb-3">
                    {selectedUsers.map(user => (
                      <div key={user.id} className="flex items-center bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm">
                        <span>{user.name}</span>
                        <button
                          type="button"
                          onClick={() => removeUser(user.id)}
                          className="ml-2 hover:bg-blue-200 rounded-full p-0.5"
                        >
                          <X size={14} />
                        </button>
                      </div>
                    ))}
                  </div>
                )}
                
                <SearchInput
                  placeholder="Buscar usuarios para invitar..."
                  onSearch={handleUserSearch}
                  suggestions={userSearchResults}
                  onSelect={handleUserSelect}
                  value=""
                  className="w-full"
                  renderSuggestion={(user) => (
                    <div className="flex items-center">
                      <div className="w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center mr-3">
                        <User size={16} className="text-gray-600" />
                      </div>
                      <div>
                        <div className="font-medium text-gray-800">{user.name}</div>
                        <div className="text-sm text-gray-500">@{user.username}</div>
                      </div>
                    </div>
                  )}
                />
              </div>
            </FormField>

            <button
              onClick={() => {
                if (validateStep(1)) goToNextStep();
              }}
              disabled={selectedUsers.length === 0}
              className={`w-full py-3 px-4 rounded-lg font-medium text-white ${
                selectedUsers.length === 0
                  ? 'bg-gray-400 cursor-not-allowed' 
                  : 'bg-purple-600 hover:bg-purple-700'
              }`}
            >
              Continuar ({selectedUsers.length} participante{selectedUsers.length !== 1 ? 's' : ''})
            </button>
          </Card>
        </div>
      </>
    );
  }

  // Step 2: Choose action
  if (currentStep === 2) {
    return (
      <>
        <div className="m-4">
          <Card>
            <div className="p-5">
              <div className="flex items-center mb-3">
                <ChevronLeft 
                  size={24} 
                  onClick={goToPrevStep}
                  className="cursor-pointer text-gray-600 mr-2"
                />
                <h1 className="text-xl font-bold text-gray-800">Elegir acción</h1>
              </div>
              <p className="text-gray-700 text-sm leading-relaxed">
                ¿Qué acción activará las transferencias automáticas? (paso 2 de 5)
              </p>
            </div>
          </Card>
        </div>

        <div className="px-4 pb-6">
          <Card className="p-6">
            <FormField
              label="Acción asociada"
              required
              description="Seleccioná la acción que activará el pacto"
            >
              <SearchInput
                placeholder="Buscar acción..."
                onSearch={handleActionSearch}
                suggestions={actionSearchResults}
                onSelect={handleActionSelect}
                value={selectedAction ? selectedAction.name : ''}
                renderSuggestion={(action) => {
                  
                  
                  return (
                    <div className="flex items-center">
                      <div className="w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center mr-3">
                        <FileText size={16} className="text-gray-600" />
                      </div>
                      <div className="flex-1">
                        <div className="font-medium text-gray-800">{action.name}</div>
                        <div className="text-sm text-gray-500">{action.description}</div>
                      </div>
        
                    </div>
                  );
                }}
              />
            </FormField>
          </Card>
        </div>
      </>
    );
  }

  // Step 3: Choose transfer direction
  if (currentStep === 3) {
    return (
      <>
        <div className="m-4">
          <Card>
            <div className="p-5">
              <div className="flex items-center mb-3">
                <ChevronLeft 
                  size={24} 
                  onClick={goToPrevStep}
                  className="cursor-pointer text-gray-600 mr-2"
                />
                <h1 className="text-xl font-bold text-gray-800">Dirección de transferencia</h1>
              </div>
              <p className="text-gray-700 text-sm leading-relaxed">
                ¿Quién transfiere karma cuando alguien hace "{selectedAction?.name}"? (paso 3 de 5)
              </p>
            </div>
          </Card>
        </div>

        <div className="px-4 pb-6">
          <Card className="p-6">
            <div className="space-y-4">
              <button
                onClick={() => handleDirectionSelect('give')}
                className="w-full border-2 border-gray-300 hover:border-blue-500 hover:bg-blue-50 rounded-lg p-6 transition-all text-left"
              >
                <div className="flex items-center">
                  <ChevronsRightLeft size={24} className="text-blue-600 mr-4" />
                  <div>
                    <div className="font-bold text-gray-800 text-lg">Todos para uno</div>
                    <div className="text-gray-600 mt-1">Los demás participantes le transfieren karma al que realiza la acción</div>
                    <div className="text-sm text-blue-700 mt-2 font-medium">
                      Ejemplo: Cuando reparo mi auto, los demás me ayudan con los gastos
                    </div>
                  </div>
                </div>
              </button>

              <button
                onClick={() => handleDirectionSelect('receive')}
                className="w-full border-2 border-gray-300 hover:border-purple-500 hover:bg-purple-50 rounded-lg p-6 transition-all text-left"
              >
                <div className="flex items-center">
                  <ChevronsLeftRight size={24} className="text-purple-600 mr-4" />
                  <div>
                    <div className="font-bold text-gray-800 text-lg">Uno para todos</div>
                    <div className="text-gray-600 mt-1">El que realiza la acción les transfiere karma a los demás participantes</div>
                    <div className="text-sm text-purple-700 mt-2 font-medium">
                      Ejemplo: Cuando gano dinero, comparto parte con los demás
                    </div>
                  </div>
                </div>
              </button>
            </div>
          </Card>
        </div>
      </>
    );
  }

  // Step 4: Choose amount
  if (currentStep === 4) {
    return (
      <>
        <div className="m-4">
          <Card>
            <div className="p-5">
              <div className="flex items-center mb-3">
                <ChevronLeft 
                  size={24} 
                  onClick={goToPrevStep}
                  className="cursor-pointer text-gray-600 mr-2"
                />
                <h1 className="text-xl font-bold text-gray-800">Cantidad a transferir</h1>
              </div>
              <p className="text-gray-700 text-sm leading-relaxed">
                ¿Cuánto karma se transferirá? (paso 4 de 5)
              </p>
            </div>
          </Card>
        </div>

        <div className="px-4 pb-6">
          <Card className="p-6">
            <div className="space-y-6">
              {/* Type Selection */}
              <FormField
                label="Tipo de transferencia"
                description="Elegí si será un porcentaje o una cantidad fija"
              >
                <div className="flex gap-3">
                  <label className={`flex-1 border-2 rounded-lg p-4 cursor-pointer transition-all ${
                    transferType === 'percentage' 
                      ? 'border-blue-500 bg-blue-50' 
                      : 'border-gray-300 hover:border-gray-400'
                  }`}>
                    <input
                      type="radio"
                      name="transferType"
                      value="percentage"
                      checked={transferType === 'percentage'}
                      onChange={(e) => setTransferType(e.target.value)}
                      className="sr-only"
                    />
                    <div className="flex items-center">
                      <Percent size={20} className="text-blue-600 mr-3" />
                      <div>
                        <div className="font-medium text-gray-800">Porcentaje</div>
                        <div className="text-sm text-gray-600">% del karma/costo</div>
                      </div>
                    </div>
                  </label>

                  <label className={`flex-1 border-2 rounded-lg p-4 cursor-pointer transition-all ${
                    transferType === 'fixed' 
                      ? 'border-purple-500 bg-purple-50' 
                      : 'border-gray-300 hover:border-gray-400'
                  }`}>
                    <input
                      type="radio"
                      name="transferType"
                      value="fixed"
                      checked={transferType === 'fixed'}
                      onChange={(e) => setTransferType(e.target.value)}
                      className="sr-only"
                    />
                    <div className="flex items-center">
                      <span className="text-purple-600 mr-3 font-bold text-lg">₭</span>
                      <div>
                        <div className="font-medium text-gray-800">Cantidad fija</div>
                        <div className="text-sm text-gray-600">Karma específico</div>
                      </div>
                    </div>
                  </label>
                </div>
              </FormField>

              {/* Amount Input */}
              <FormField
                label={`${transferType === 'percentage' ? 'Porcentaje' : 'Cantidad'} a transferir`}
                required
                error={errors.amount}
              >
                <div className="relative">
                  <input
                    type="number"
                    step={transferType === 'percentage' ? '1' : '0.1'}
                    max={transferType === 'percentage' ? '100' : '10000'}
                    min="0.1"
                    value={transferAmount}
                    onChange={(e) => handleTransferAmountChange(e.target.value)}
                    placeholder={transferType === 'percentage' ? 'Ej: 20' : 'Ej: 50.5'}
                    className={`w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent ${
                      errors.amount ? 'border-red-500' : 'border-gray-300'
                    }`}
                  />
                  <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                    <span className="text-gray-500 font-medium">
                      {transferType === 'percentage' ? '%' : '₭'}
                    </span>
                  </div>
                </div>
              </FormField>

              <button
                onClick={() => {
                  if (validateStep(4)) goToNextStep();
                }}
                disabled={!transferAmount || isNaN(parseFloat(transferAmount))}
                className={`w-full py-3 px-4 rounded-lg font-medium text-white ${
                  !transferAmount || isNaN(parseFloat(transferAmount))
                    ? 'bg-gray-400 cursor-not-allowed' 
                    : 'bg-purple-600 hover:bg-purple-700'
                }`}
              >
                Continuar
              </button>
            </div>
          </Card>
        </div>
      </>
    );
  }

  // Step 5: Summary and submit
  if (currentStep === 5) {
    const numAmount = parseFloat(transferAmount) || 0;
    const totalParticipants = selectedUsers.length + 1;
    const isReceiving = transferDirection === 'receive';
    const isPercentage = transferType === 'percentage';

    return (
      <>
        <div className="m-4">
          <Card>
            <div className="p-5">
              <div className="flex items-center mb-3">
                <ChevronLeft 
                  size={24} 
                  onClick={goToPrevStep}
                  className="cursor-pointer text-gray-600 mr-2"
                />
                <h1 className="text-xl font-bold text-gray-800">Resumen del pacto</h1>
              </div>
              <p className="text-gray-700 text-sm leading-relaxed">
                Revisá los detalles antes de proponer el pacto (paso 5 de 5)
              </p>
            </div>
          </Card>
        </div>

        <div className="px-4 pb-6">
          <Card className="p-6">
            <div className="space-y-6">
              {/* Summary */}
              <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
                <h3 className="font-bold text-gray-800 mb-4">Detalles del pacto:</h3>
                <div className="space-y-3 text-sm">
                  <div className="flex justify-between">
                    <span className="text-gray-600">Acción:</span>
                    <span className="font-medium text-gray-800">{selectedAction.name}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-600">Participantes:</span>
                    <span className="font-medium text-gray-800">{totalParticipants} total</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-600">Dirección:</span>
                    <span className="font-medium text-gray-800">
                      {transferDirection === 'give' ? 'Todos → Uno' : 'Uno → Todos'}
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-600">Cantidad:</span>
                    <span className="font-medium text-gray-800">
                      {isPercentage ? `${numAmount}%` : `₭${numAmount}`}
                    </span>
                  </div>
                </div>
              </div>

              {/* Dynamic explanation */}
              <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <h4 className="font-medium text-blue-800 mb-2">Cuando cualquier participante realice "{selectedAction.name}":</h4>
                <div className="text-blue-700 text-sm">
                  {transferDirection === 'give' ? (
                    <p>
                      → Los otros {selectedUsers.length} participantes le darán{' '}
                      <strong>
                        {isPercentage ? `${numAmount}%` : `₭${numAmount}`}
                      </strong>
                      {isPercentage && ' cada uno'}
                    </p>
                  ) : (
                    <p>
                      → Se les dará a los otros {selectedUsers.length} participantes{' '}
                      <strong>
                        {isPercentage ? `${numAmount}%` : `₭${numAmount}`}
                      </strong>
                      {isPercentage ? ' del total' : ' cada uno'}
                    </p>
                  )}
                </div>
              </div>

              {/* Participants list */}
              <div>
                <h4 className="font-medium text-gray-800 mb-2">Participantes invitados:</h4>
                <div className="flex flex-wrap gap-2">
                  {selectedUsers.map(user => (
                    <div key={user.id} className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm">
                      {user.name}
                    </div>
                  ))}
                </div>
              </div>

              {/* Submit Error */}
              {errors.submit && (
                <div className="p-3 bg-red-50 border border-red-200 rounded-lg flex items-center">
                  <AlertCircle size={18} className="text-red-500 mr-2" />
                  <span className="text-red-700 text-sm">{errors.submit}</span>
                </div>
              )}

              {/* Submit Button */}
              <button
                onClick={handleSubmit}
                disabled={isSubmitting}
                className={`w-full py-4 px-4 rounded-lg font-medium text-white ${
                  isSubmitting
                    ? 'bg-gray-400 cursor-not-allowed' 
                    : 'bg-purple-600 hover:bg-purple-700'
                }`}
              >
                {isSubmitting ? 'Creando pacto...' : 'Proponer pacto'}
              </button>
            </div>
          </Card>
        </div>
      </>
    );
  }
}


//src/components/screens/PescadoresDetailScreen.jsx

"use client";

import React from 'react';
import { 
  Fish, 
  LogOut,
  UserPlus,
  MapPin,
  ShoppingBag,
  Baby,
  Plus,
  Globe
} from 'lucide-react';
import Card from '@/components/ui/Card';
import ActionItem from '@/components/ui/ActionItem';
import SectionTitle from '@/components/ui/SectionTitle';
import ActionRow from '@/components/ui/ActionRow';
import MinkaListItem from '@/components/ui/MinkaListItem';
import CreateMinkaButton from '@/components/ui/CreateMinkaButton';

export default function PescadoresDetailScreen() {
  return (
    <>
      {/* Pescadores Title Card */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <div className="flex items-center mb-3">
              <div className="w-12 h-12 rounded-lg bg-blue-50 flex items-center justify-center mr-4">
                <Fish size={28} className="text-blue-700" />
              </div>
              <div>
                <h1 className="text-2xl font-bold text-gray-800">PESCADORES</h1>
              </div>
            </div>
            <p className="text-gray-700 text-sm leading-relaxed">
              Fomentar la pesca nacional segura y sustentable.
            </p>
          </div>
        </Card>
      </div>

      {/* Participation Section */}
      <div className="px-4 pb-4">
        <Card className="p-4">
          <h3 className="text-sm font-medium text-gray-700 mb-3">Participación</h3>
          <div className="grid grid-cols-2 gap-4">
            <ActionItem 
              icon={<LogOut size={20} className="text-gray-700" />}
              label="Abandonar minka"
            />
            <ActionItem 
              icon={<UserPlus size={20} className="text-blue-700" />}
              label="Invitar miembro"
              highlight={true}
            />
          </div>
        </Card>
      </div>

      {/* Valued Actions Section */}
      <SectionTitle 
        title="Acciones valoradas" 
        actionText="Ver todas" 
        onAction={() => console.log('Ver todas acciones')} 
      />

      <div className="px-4 pb-4">
        <Card>
          <ActionRow 
            icon={<MapPin size={18} className="text-gray-600" />}
            title="Emprender viaje"
            subtitle="Salir de pesca con barco mediano a mar abierto"
            value="+ ₭ 500"
            valueColor="text-green-600"
            actionId="emprender-viaje"
            scopeIcon={<Fish size={14} className="text-blue-600" />}
            scopeLabel="Pescadores"
            miVoto="-0.5₭"
            resultado="-0.7₭"
          />
          <ActionRow 
            icon={<ShoppingBag size={18} className="text-gray-600" />}
            title="Vender pescado"
            subtitle="Comercializar la pesca del día en el mercado local"
            value="⇆ 20%"
            valueColor="text-gray-600"
            actionId="vender-pescado"
            scopeIcon={<Fish size={14} className="text-blue-600" />}
            scopeLabel="Pescadores"
            miVoto="0₭"
            resultado="+0.2₭"
          />
          <ActionRow 
            icon={<Baby size={18} className="text-gray-600" />}
            title="Pescar trucha bebé"
            subtitle="Perjudicar la sustentabilidad del ecosistema marino"
            value="- ₭ 200"
            valueColor="text-red-600"
            actionId="pescar-trucha-bebe"
            scopeIcon={<Globe size={14} className="text-green-600" />}
            scopeLabel="Global"
            miVoto="-0.5₭"
            resultado="-0.7₭"
          />
        </Card>
      </div>

      {/* Ver todas las acciones button */}
      <div className="px-4 pb-4">
        <button 
          onClick={() => console.log('Ver todas las acciones valoradas por pescadores')}
          className="w-full py-3 px-4 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 font-medium border border-gray-300"
        >
          Ver todas las acciones valoradas por pescadores
        </button>
      </div>

      {/* Sub-Minkas Section */}
      <SectionTitle 
        title="Minkas en Pescadores" 
        actionText="Ver todas"
        onAction={() => console.log('Ver todas las minkas')}
      />

      <div className="px-4 pb-4">
        <Card>
          <MinkaListItem 
            icon={
              <div className="w-10 h-10 rounded-lg bg-blue-50 flex items-center justify-center">
                <Fish size={20} className="text-blue-600" />
              </div>
            }
            title="Atuneros"
            subtitle="12 miembros"
            value="₭ 100"
            isPositive={true}
            isMember={true}
          />
          
          <MinkaListItem 
            icon={
              <div className="w-10 h-10 rounded-lg bg-blue-50 flex items-center justify-center">
                <Fish size={20} className="text-blue-600" />
              </div>
            }
            title="Agua dulce"
            subtitle="50 miembros"
            value="₭ 22"
            isPositive={true}
            isMember={false}
          />
          
          <MinkaListItem 
            icon={
              <div className="w-10 h-10 rounded-lg bg-blue-50 flex items-center justify-center">
                <Fish size={20} className="text-blue-600" />
              </div>
            }
            title="Truchas"
            subtitle="35 miembros"
            value="₭ 12"
            isPositive={false}
            isMember={false}
          />
        </Card>
      </div>

      {/* Ver todas las minkas button */}
      <div className="px-4 pb-6">
        <button 
          onClick={() => console.log('Ver todas las minkas en pescadores')}
          className="w-full py-3 px-4 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 font-medium border border-gray-300"
        >
          Ver todas las minkas en pescadores
        </button>
      </div>
    </>
  );
}


//src/components/screens/ReportarActoScreen.jsx

"use client";

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import { CheckCircle, AlertCircle, User, FileText, Eye } from 'lucide-react';
import Card from '@/components/ui/Card';
import FormField from '@/components/shared/FormField';
import SearchInput from '@/components/shared/SearchInput';
import MarkdownEditor from '@/components/shared/MarkdownEditor';
import MarkdownViewer from '@/components/shared/MarkdownViewer';
import { dataService } from '@/services/dataService';

export default function ReportarActoScreen() {
  const router = useRouter();
  const [selectedActor, setSelectedActor] = useState(null);
  const [selectedAction, setSelectedAction] = useState(null);
  const [evidencia, setEvidencia] = useState('');
  const [fechaHora, setFechaHora] = useState('');
  
  const [userSearchResults, setUserSearchResults] = useState([]);
  const [actionSearchResults, setActionSearchResults] = useState([]);
  
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const [showActionDetails, setShowActionDetails] = useState(false);

  // Handle user search
  const handleUserSearch = async (query) => {
    try {
      const results = await dataService.searchUsers(query);
      setUserSearchResults(results);
    } catch (error) {
      console.error('Error searching users:', error);
      setUserSearchResults([]);
    }
  };

  const handleUserSelect = (user) => {
    setSelectedActor(user);
    setUserSearchResults([]);
    
    // Clear error when user is selected
    if (errors.actor) {
      setErrors(prev => ({ ...prev, actor: '' }));
    }
  };

  // Handle action search
  const handleActionSearch = async (query) => {
    try {
      const results = await dataService.searchActions(query);
      setActionSearchResults(results);
    } catch (error) {
      console.error('Error searching actions:', error);
      setActionSearchResults([]);
    }
  };

  const handleActionSelect = async (action) => {
    try {
      // Get action with full details for display
      const actionWithDetails = await dataService.getActionWithDetails(action.id);
      setSelectedAction(actionWithDetails);
      setActionSearchResults([]);
      setShowActionDetails(true);
      
      // Clear error when action is selected
      if (errors.action) {
        setErrors(prev => ({ ...prev, action: '' }));
      }
    } catch (error) {
      console.error('Error fetching action details:', error);
      setSelectedAction(action);
      setActionSearchResults([]);
      setShowActionDetails(true);
    }
  };

  // Handle evidence change
  const handleEvidenciaChange = (value) => {
    setEvidencia(value || '');
    
    // Clear error when user starts typing
    if (errors.evidencia) {
      setErrors(prev => ({ ...prev, evidencia: '' }));
    }
  };

  // Handle date/time change
  const handleFechaHoraChange = (value) => {
    setFechaHora(value);
    
    // Clear error when user selects date
    if (errors.fechaHora) {
      setErrors(prev => ({ ...prev, fechaHora: '' }));
    }
  };

  // Form validation
  const validateForm = () => {
    const newErrors = {};

    if (!selectedActor) {
      newErrors.actor = 'Debe seleccionar el actor que realizó la acción';
    }

    if (!selectedAction) {
      newErrors.action = 'Debe seleccionar la acción reportada';
    }

    if (!fechaHora) {
      newErrors.fechaHora = 'Debe especificar cuándo ocurrió la acción';
    }

    if (!evidencia.trim()) {
      newErrors.evidencia = 'Debe proporcionar evidencia de la acción';
    } else if (evidencia.length < 50) {
      newErrors.evidencia = 'La evidencia debe tener al menos 50 caracteres';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);
    
    try {
      const reportData = {
        actionId: selectedAction.id,
        actorId: selectedActor.id,
        reporterId: '1', // Current user (Juan)
        evidencia: evidencia,
        fechaHoraActo: fechaHora
      };
      
      const savedReport = await dataService.createReport(reportData);
      console.log('Report saved:', savedReport);
      
      setShowSuccess(true);
      
      // Reset form after success
      setTimeout(() => {
        setSelectedActor(null);
        setSelectedAction(null);
        setEvidencia('');
        setFechaHora('');
        setShowActionDetails(false);
        setShowSuccess(false);
        router.push('/'); // Navigate back to home
      }, 3000);
      
    } catch (error) {
      console.error('Error saving report:', error);
      setErrors({ submit: 'Error al guardar el reporte. Intenta nuevamente.' });
    } finally {
      setIsSubmitting(false);
    }
  };

  const defaultEvidencia = `# Evidencia del acto reportado

## Fecha y hora
[Especificar cuándo ocurrió la acción]

## Ubicación
[Dónde sucedió la acción]

## Evidencia presentada
- **Fotografías**: [Descripción de las fotos]
- **Documentos**: [Documentos que respaldan el reporte]
- **Testigos**: [Personas que presenciaron la acción]

## Descripción detallada
[Descripción completa de lo que ocurrió]

## Observaciones adicionales
[Cualquier información adicional relevante]`;

  // Render success state
  if (showSuccess) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <CheckCircle size={48} className="text-green-500 mx-auto mb-4" />
          <h2 className="text-xl font-bold text-gray-800 mb-2">¡Reporte enviado exitosamente!</h2>
          <p className="text-gray-600 mb-4">
            Se ha reportado que <strong>{selectedActor?.name}</strong> realizó la acción <strong>"{selectedAction?.name}"</strong>.
          </p>
          <p className="text-sm text-gray-500">
            El reporte será enviado para validación por la comunidad.
          </p>
        </Card>
      </div>
    );
  }

  return (
    <>
      {/* Title Card */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <h1 className="text-xl font-bold text-gray-800 mb-3">Reportar acto</h1>
            <p className="text-gray-700 text-sm leading-relaxed">
              Reportá que alguien realizó una acción específica y proporcioná la evidencia correspondiente.
            </p>
          </div>
        </Card>
      </div>

      {/* Form */}
      <div className="px-4 pb-6">
        <Card className="p-6">
          <form onSubmit={handleSubmit} className="space-y-6">
            
            {/* Actor Selection */}
            <FormField
              label="Actor"
              required
              error={errors.actor}
              description="Buscá y seleccioná la persona que realizó la acción"
            >
              <SearchInput
                placeholder="Buscar usuario por nombre o username..."
                onSearch={handleUserSearch}
                suggestions={userSearchResults}
                onSelect={handleUserSelect}
                value={selectedActor ? `${selectedActor.name} (@${selectedActor.username})` : ''}
                renderSuggestion={(user) => (
                  <div className="flex items-center">
                    <div className="w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center mr-3">
                      <User size={16} className="text-gray-600" />
                    </div>
                    <div>
                      <div className="font-medium text-gray-800">{user.name}</div>
                      <div className="text-sm text-gray-500">@{user.username}</div>
                    </div>
                  </div>
                )}
              />
            </FormField>

            {/* Action Selection */}
            <FormField
              label="Acción reportada"
              required
              error={errors.action}
              description="Buscá y seleccioná la acción que fue realizada"
            >
              <SearchInput
                placeholder="Buscar acción por nombre..."
                onSearch={handleActionSearch}
                suggestions={actionSearchResults}
                onSelect={handleActionSelect}
                value={selectedAction ? selectedAction.name : ''}
                renderSuggestion={(action) => {
                  
                  
                  return (
                    <div className="flex items-center">
                      <div className="w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center mr-3">
                        <FileText size={16} className="text-gray-600" />
                      </div>
                      <div className="flex-1">
                        <div className="font-medium text-gray-800">{action.name}</div>
                        <div className="text-sm text-gray-500">{action.description}</div>
                      </div>
                      
                    </div>
                  );
                }}
              />
            </FormField>

            {/* Date and Time Selection */}
            <FormField
              label="Fecha y hora del acto"
              required
              error={errors.fechaHora}
              description="¿Cuándo ocurrió la acción reportada?"
            >
              <input
                type="datetime-local"
                value={fechaHora}
                onChange={(e) => handleFechaHoraChange(e.target.value)}
                className={`w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent ${
                  errors.fechaHora ? 'border-red-500' : 'border-gray-300'
                }`}
              />
            </FormField>

            {/* Action Details Display */}
            {selectedAction && (
              <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                <div className="flex items-center justify-between mb-3">
                  <h3 className="font-medium text-gray-800">Acción seleccionada</h3>
                  <button
                    type="button"
                    onClick={() => setShowActionDetails(!showActionDetails)}
                    className="flex items-center text-blue-600 text-sm hover:text-blue-700"
                  >
                    <Eye size={16} className="mr-1" />
                    {showActionDetails ? 'Ocultar' : 'Ver'} detalles
                  </button>
                </div>
                
                <div className="mb-2">
                  <div className="font-medium text-gray-800">{selectedAction.name}</div>
                  <div className="text-sm text-gray-600 mb-2">{selectedAction.description}</div>
                </div>

                {showActionDetails && selectedAction.detalles && (
                  <div className="mt-4 border-t border-blue-200 pt-4">
                    <h4 className="font-medium text-gray-800 mb-2">Descripción completa:</h4>
                    <div className="bg-white rounded p-3 max-h-60 overflow-y-auto">
                      <MarkdownViewer content={selectedAction.detalles} />
                    </div>
                  </div>
                )}

                <div className="mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded">
                  <p className="text-sm text-yellow-800">
                    <strong>Atención:</strong> Leé cuidadosamente la descripción de la acción antes de escribir tu evidencia. 
                    Asegurate de que la evidencia demuestre claramente que la acción descrita efectivamente ocurrió.
                  </p>
                </div>
              </div>
            )}

            {/* Evidence Section */}
            {selectedAction && (
              <FormField
                label="Evidencia"
                required
                error={errors.evidencia}
                description="Proporcioná evidencia detallada de que la acción reportada efectivamente ocurrió"
              >
                <div className={`border rounded-lg ${errors.evidencia ? 'border-red-500' : 'border-gray-300'}`}>
                  <MarkdownEditor
                    value={evidencia || defaultEvidencia}
                    onChange={handleEvidenciaChange}
                    placeholder="Describí la evidencia que tenés..."
                    height={300}
                  />
                </div>
                <p className="text-xs text-gray-500 mt-2">
                  Incluí fotos, documentos, testigos, ubicación, fecha/hora y cualquier detalle relevante
                </p>
              </FormField>
            )}

            {/* Submit Error */}
            {errors.submit && (
              <div className="p-3 bg-red-50 border border-red-200 rounded-lg flex items-center">
                <AlertCircle size={18} className="text-red-500 mr-2" />
                <span className="text-red-700 text-sm">{errors.submit}</span>
              </div>
            )}

            {/* Submit Button */}
            <div className="flex gap-3 pt-4">
              <button
                type="button"
                onClick={() => router.back()}
                className="flex-1 py-3 px-4 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 font-medium"
              >
                Cancelar
              </button>
              <button
                type="submit"
                disabled={isSubmitting || !selectedActor || !selectedAction}
                className={`flex-1 py-3 px-4 rounded-lg font-medium text-white ${
                  isSubmitting || !selectedActor || !selectedAction
                    ? 'bg-gray-400 cursor-not-allowed' 
                    : 'bg-blue-600 hover:bg-blue-700'
                }`}
              >
                {isSubmitting ? 'Enviando reporte...' : 'Reportar acto'}
              </button>
            </div>
          </form>
        </Card>
      </div>
    </>
  );
}


//src/components/screens/TransferirScreen.jsx

"use client";

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import { CheckCircle, AlertCircle, User, ArrowRight, Minus } from 'lucide-react';
import Card from '@/components/ui/Card';
import FormField from '@/components/shared/FormField';
import SearchInput from '@/components/shared/SearchInput';
import { dataService } from '@/services/dataService';

export default function TransferirScreen() {
  const router = useRouter();
  
  const [selectedUser, setSelectedUser] = useState(null);
  const [karmaAmount, setKarmaAmount] = useState('');
  const [motivo, setMotivo] = useState('');
  
  const [userSearchResults, setUserSearchResults] = useState([]);
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);

  // Handle user search
  const handleUserSearch = async (query) => {
    try {
      const results = await dataService.searchUsers(query);
      // Filter out current user (Juan)
      const filteredResults = results.filter(user => user.id !== '1');
      setUserSearchResults(filteredResults);
    } catch (error) {
      console.error('Error searching users:', error);
      setUserSearchResults([]);
    }
  };

  const handleUserSelect = (user) => {
    setSelectedUser(user);
    setUserSearchResults([]);
    
    // Clear error when user is selected
    if (errors.user) {
      setErrors(prev => ({ ...prev, user: '' }));
    }
  };

  // Handle karma amount change
  const handleKarmaChange = (value) => {
    setKarmaAmount(value);
    
    // Clear error when user starts typing
    if (errors.karma) {
      setErrors(prev => ({ ...prev, karma: '' }));
    }
  };

  // Handle motivo change
  const handleMotivoChange = (value) => {
    setMotivo(value);
    
    // Clear error when user starts typing
    if (errors.motivo) {
      setErrors(prev => ({ ...prev, motivo: '' }));
    }
  };

  // Validate form
  const validateForm = () => {
    const newErrors = {};
    
    if (!selectedUser) {
      newErrors.user = 'Debe seleccionar un usuario destinatario';
    }
    
    if (!karmaAmount.trim()) {
      newErrors.karma = 'Debe ingresar una cantidad de karma';
    } else {
      const numValue = parseFloat(karmaAmount);
      if (isNaN(numValue)) {
        newErrors.karma = 'La cantidad debe ser un número válido';
      } else if (numValue === 0) {
        newErrors.karma = 'La cantidad no puede ser cero';
      } else if (Math.abs(numValue) > 10000) {
        newErrors.karma = 'La cantidad debe estar entre -10,000 y 10,000';
      }
    }

    if (!motivo.trim()) {
      newErrors.motivo = 'Debe explicar el motivo de la transferencia';
    } else if (motivo.length < 10) {
      newErrors.motivo = 'El motivo debe tener al menos 10 caracteres';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);
    
    try {
      const transferData = {
        fromUserId: '1', // Current user Juan
        toUserId: selectedUser.id,
        amount: parseFloat(karmaAmount),
        motivo: motivo,
        timestamp: new Date().toISOString()
      };
      
      const result = await dataService.createTransfer(transferData);
      console.log('Transfer saved:', result);
      setShowSuccess(true);
      
      // Navigate back after success
      setTimeout(() => {
        router.push('/');
      }, 2500);
      
    } catch (error) {
      console.error('Error saving transfer:', error);
      setErrors({ submit: 'Error al procesar la transferencia. Intenta nuevamente.' });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Calculate values for dynamic explanation
  const karmaNum = parseFloat(karmaAmount) || 0;
  const isPositive = karmaNum > 0;
  const absAmount = Math.abs(karmaNum);

  // Success state
  if (showSuccess) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <CheckCircle size={48} className="text-green-500 mx-auto mb-4" />
          <h2 className="text-xl font-bold text-gray-800 mb-2">¡Enviado!</h2>
          <p className="text-gray-600 mb-4">
            {isPositive ? (
              <>Se han enviado <strong>₭{absAmount}</strong> a <strong>{selectedUser?.name}</strong></>
            ) : (
              <>Se han pagado <strong>₭{absAmount}</strong> para penalizar a <strong>{selectedUser?.name}</strong></>
            )}
          </p>
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
            <p className="text-blue-800 text-sm">
              <strong>Motivo:</strong> {motivo}
            </p>
          </div>
        </Card>
      </div>
    );
  }

  return (
    <>
      {/* Title Card */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <h1 className="text-xl font-bold text-gray-800 mb-3">Transferir</h1>
            <p className="text-gray-700 text-sm leading-relaxed">
              Enviá karma a otro usuario o pagá para penalizarlo.
            </p>
          </div>
        </Card>
      </div>

      {/* Transfer Form */}
      <div className="px-4 pb-6">
        <Card className="p-6">
          <form onSubmit={handleSubmit} className="space-y-6">
            
            {/* User Selection */}
            <FormField
              label="Usuario destinatario"
              required
              error={errors.user}
              description="Buscá y seleccioná el usuario que recibirá la transferencia"
            >
              <SearchInput
                placeholder="Buscar usuario por nombre o username..."
                onSearch={handleUserSearch}
                suggestions={userSearchResults}
                onSelect={handleUserSelect}
                value={selectedUser ? `${selectedUser.name} (@${selectedUser.username})` : ''}
                renderSuggestion={(user) => (
                  <div className="flex items-center">
                    <div className="w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center mr-3">
                      <User size={16} className="text-gray-600" />
                    </div>
                    <div>
                      <div className="font-medium text-gray-800">{user.name}</div>
                      <div className="text-sm text-gray-500">@{user.username}</div>
                    </div>
                  </div>
                )}
              />
            </FormField>

            {/* Karma Amount */}
            <FormField
              label="Cantidad de karma"
              required
              error={errors.karma}
              description="Ingresá un número positivo para enviar, o negativo para penalizar"
            >
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <span className="text-gray-500 text-lg">₭</span>
                </div>
                <input
                  type="number"
                  step="0.1"
                  value={karmaAmount}
                  onChange={(e) => handleKarmaChange(e.target.value)}
                  placeholder="Ej: 50, -25, 12.5"
                  className={`w-full pl-8 pr-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent ${
                    errors.karma ? 'border-red-500' : 'border-gray-300'
                  }`}
                />
              </div>
            </FormField>

            {/* Dynamic Explanation */}
            {selectedUser && karmaAmount && !isNaN(parseFloat(karmaAmount)) && karmaNum !== 0 && (
              <div className={`p-4 border rounded-lg ${
                isPositive 
                  ? 'bg-green-50 border-green-200' 
                  : 'bg-red-50 border-red-200'
              }`}>
                <div className="flex items-center">
                  {isPositive ? (
                    <ArrowRight size={20} className="text-green-600 mr-3" />
                  ) : (
                    <Minus size={20} className="text-red-600 mr-3" />
                  )}
                  <div>
                    {isPositive ? (
                      <p className="text-green-800 font-medium">
                        Enviar <strong>₭{absAmount}</strong> a <strong>{selectedUser.name}</strong>
                      </p>
                    ) : (
                      <p className="text-red-800 font-medium">
                        Pagar <strong>₭{absAmount}</strong> para penalizar a <strong>{selectedUser.name}</strong> en <strong>₭{absAmount}</strong>
                      </p>
                    )}
                  </div>
                </div>
              </div>
            )}

            {/* Motivo */}
            <FormField
              label="Motivo"
              required
              error={errors.motivo}
              description={`Explicá el motivo de la transacción. ${selectedUser?.name || 'El usuario'} no sabrá que fuiste vos, pero sí podrá ver el motivo de la transacción.`}
            >
              <textarea
                value={motivo}
                onChange={(e) => handleMotivoChange(e.target.value)}
                placeholder="Ej: Por ayudarme con el trabajo, Por comportamiento inapropiado en el chat..."
                rows={4}
                className={`w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none ${
                  errors.motivo ? 'border-red-500' : 'border-gray-300'
                }`}
              />
              <div className="flex justify-between text-xs text-gray-500 mt-1">
                <span>{motivo.length} caracteres</span>
                <span>Mínimo 10 caracteres</span>
              </div>
            </FormField>

            {/* Privacy Notice */}
            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
              <div className="flex items-start">
                <AlertCircle size={16} className="text-blue-600 mr-2 mt-0.5 flex-shrink-0" />
                <div className="text-blue-800 text-sm">
                  <p className="font-medium mb-1">Transferencia anónima</p>
                  <p>El destinatario verá el motivo pero no sabrá que la transferencia vino de vos.</p>
                </div>
              </div>
            </div>

            {/* Submit Error */}
            {errors.submit && (
              <div className="p-3 bg-red-50 border border-red-200 rounded-lg flex items-center">
                <AlertCircle size={18} className="text-red-500 mr-2" />
                <span className="text-red-700 text-sm">{errors.submit}</span>
              </div>
            )}

            {/* Submit Button */}
            <div className="flex gap-3 pt-4">
              <button
                type="button"
                onClick={() => router.back()}
                className="flex-1 py-3 px-4 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 font-medium"
              >
                Cancelar
              </button>
              <button
                type="submit"
                disabled={isSubmitting || !selectedUser || !karmaAmount || !motivo.trim()}
                className={`flex-1 py-3 px-4 rounded-lg font-medium text-white ${
                  isSubmitting || !selectedUser || !karmaAmount || !motivo.trim()
                    ? 'bg-gray-400 cursor-not-allowed' 
                    : isPositive 
                      ? 'bg-green-600 hover:bg-green-700'
                      : 'bg-red-600 hover:bg-red-700'
                }`}
              >
                {isSubmitting ? 'Procesando...' : 
                 karmaNum > 0 ? 'Transferir' :
                 karmaNum < 0 ? 'Penalizar' :
                 'Enviar transferencia'}
              </button>
            </div>
          </form>
        </Card>
      </div>
    </>
  );
}


//src/components/screens/ValidarActoScreen.jsx

"use client";

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { CheckCircle, XCircle, AlertTriangle, User, FileText, Calendar, MapPin } from 'lucide-react';
import Card from '@/components/ui/Card';
import MarkdownViewer from '@/components/shared/MarkdownViewer';
import { dataService } from '@/services/dataService';

export default function ValidarActoScreen() {
  const router = useRouter();
  const [pendingReports, setPendingReports] = useState([]);
  const [currentReport, setCurrentReport] = useState(null);
  const [currentActor, setCurrentActor] = useState(null);
  const [currentAction, setCurrentAction] = useState(null);
  const [decision, setDecision] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const [currentIndex, setCurrentIndex] = useState(0);

  // Load pending reports on component mount
  useEffect(() => {
    loadPendingReports();
  }, []);

  const loadPendingReports = async () => {
    try {
      const reports = await dataService.getPendingReports();
      setPendingReports(reports);
      
      if (reports.length > 0) {
        loadReport(reports[0], 0);
      }
    } catch (error) {
      console.error('Error loading pending reports:', error);
    }
  };

  // Load a specific report with its related data
  const loadReport = async (report, index) => {
    try {
      const [actor, action] = await Promise.all([
        dataService.getUserById(report.actorId),
        dataService.getActionById(report.actionId)
      ]);
      
      setCurrentReport(report);
      setCurrentActor(actor);
      setCurrentAction(action);
      setCurrentIndex(index);
      setDecision(null);
    } catch (error) {
      console.error('Error loading report details:', error);
    }
  };

  // Handle validation decision
  const handleValidation = async (isValid) => {
    if (!currentReport) return;

    setIsSubmitting(true);
    
    try {
      // Validate the report
      await dataService.validateReport(currentReport.id, isValid, '1'); // Current user Juan as validator
      
      setDecision(isValid);
      setShowSuccess(true);
      
      // Move to next report after showing success
      setTimeout(() => {
        const nextIndex = currentIndex + 1;
        if (nextIndex < pendingReports.length) {
          loadReport(pendingReports[nextIndex], nextIndex);
          setShowSuccess(false);
        } else {
          // No more reports to validate
          router.push('/');
        }
      }, 2000);
      
    } catch (error) {
      console.error('Error validating report:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  // Format date for display
  const formatDate = (dateString) => {
    if (!dateString) return 'No especificada';
    const date = new Date(dateString);
    return date.toLocaleDateString('es-AR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  // Show success state
  if (showSuccess && decision !== null) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          {decision ? (
            <>
              <CheckCircle size={48} className="text-green-500 mx-auto mb-4" />
              <h2 className="text-xl font-bold text-gray-800 mb-2">¡Validación confirmada!</h2>
              <p className="text-gray-600 mb-4">
                Has confirmado que <strong>{currentActor?.name}</strong> efectivamente realizó la acción <strong>"{currentAction?.name}"</strong>.
              </p>
            </>
          ) : (
            <>
              <XCircle size={48} className="text-red-500 mx-auto mb-4" />
              <h2 className="text-xl font-bold text-gray-800 mb-2">Reporte rechazado</h2>
              <p className="text-gray-600 mb-4">
                Has determinado que la evidencia no es suficiente para confirmar que <strong>{currentActor?.name}</strong> realizó la acción <strong>"{currentAction?.name}"</strong>.
              </p>
            </>
          )}
          <div className="bg-green-50 border border-green-200 rounded-lg p-3">
            <p className="text-green-800 font-medium">
              +₭50 ganados por tu validación
            </p>
          </div>
        </Card>
      </div>
    );
  }

  // Show empty state if no pending reports
  if (pendingReports.length === 0) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <CheckCircle size={48} className="text-gray-400 mx-auto mb-4" />
          <h2 className="text-xl font-bold text-gray-800 mb-2">¡Todo al día!</h2>
          <p className="text-gray-600">
            No hay reportes pendientes de validación en este momento.
          </p>
          <button
            onClick={() => router.push('/')}
            className="mt-4 px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Volver al inicio
          </button>
        </Card>
      </div>
    );
  }

  // Show loading state
  if (!currentReport || !currentActor || !currentAction) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-gray-600">Cargando reporte...</p>
        </Card>
      </div>
    );
  }

  return (
    <>
      {/* Title and Progress */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <div className="flex items-center justify-between mb-3">
              <h1 className="text-xl font-bold text-gray-800">Validar acto</h1>
              <div className="text-sm text-gray-500">
                {currentIndex + 1} de {pendingReports.length}
              </div>
            </div>
            
            {/* Summary */}
            <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
              <div className="flex items-start">
                <AlertTriangle size={20} className="text-yellow-600 mr-3 mt-0.5 flex-shrink-0" />
                <div>
                  <p className="text-yellow-800 font-medium mb-1">
                    Se reportó que <strong>{currentActor.name}</strong> realizó la acción <strong>"{currentAction.name}"</strong>
                  </p>
                  <p className="text-yellow-700 text-sm">
                    Hay <strong>₭50</strong> en juego si respondés correctamente.
                  </p>
                </div>
              </div>
            </div>

            {/* Report Details */}
            <div className="grid grid-cols-2 gap-4 text-sm">
              <div className="flex items-center">
                <User size={16} className="text-gray-500 mr-2" />
                <span className="text-gray-600">Actor:</span>
                <span className="font-medium text-gray-800 ml-2">{currentActor.name}</span>
              </div>
              <div className="flex items-center">
                <Calendar size={16} className="text-gray-500 mr-2" />
                <span className="text-gray-600">Fecha del acto:</span>
                <span className="font-medium text-gray-800 ml-2">
                  {formatDate(currentReport.fechaHoraActo)}
                </span>
              </div>
            </div>
          </div>
        </Card>
      </div>

      {/* Action Description */}
      <div className="px-4 pb-4">
        <Card>
          <div className="p-4">
            <div className="flex items-center mb-3">
              <FileText size={18} className="text-blue-600 mr-2" />
              <h3 className="font-medium text-gray-800">Descripción de la acción</h3>
              <div className="ml-auto text-sm font-medium text-blue-600">
                Acción: {currentAction.name}
              </div>
            </div>
            
            <div className="mb-3">
              <h4 className="font-medium text-gray-800">{currentAction.name}</h4>
              <p className="text-sm text-gray-600 mb-2">{currentAction.description}</p>
            </div>

            <div className="bg-gray-50 rounded-lg p-4 max-h-60 overflow-y-auto">
              <MarkdownViewer content={currentAction.fullDescription || `# ${currentAction.name}\n\n${currentAction.description}`} />
            </div>
          </div>
        </Card>
      </div>

      {/* Evidence */}
      <div className="px-4 pb-4">
        <Card>
          <div className="p-4">
            <div className="flex items-center mb-3">
              <MapPin size={18} className="text-green-600 mr-2" />
              <h3 className="font-medium text-gray-800">Evidencia presentada</h3>
            </div>
            
            <div className="text-xs text-gray-500 mb-3">
              Reportado el {formatDate(currentReport.createdAt)}
            </div>

            <div className="bg-gray-50 rounded-lg p-4 max-h-80 overflow-y-auto">
              <MarkdownViewer content={currentReport.evidencia} />
            </div>
          </div>
        </Card>
      </div>

      {/* Validation Question */}
      <div className="px-4 pb-6">
        <Card>
          <div className="p-6">
            <h3 className="font-medium text-gray-800 mb-4 text-center">
              Dada la evidencia, ¿dirías que la acción fue reportada correctamente?
            </h3>
            
            <div className="flex gap-4">
              <button
                onClick={() => handleValidation(false)}
                disabled={isSubmitting}
                className={`flex-1 py-4 px-4 rounded-lg font-medium border-2 transition-all ${
                  isSubmitting 
                    ? 'bg-gray-100 text-gray-400 border-gray-200 cursor-not-allowed' 
                    : 'bg-red-50 text-red-700 border-red-200 hover:bg-red-100 hover:border-red-300'
                }`}
              >
                <div className="flex items-center justify-center">
                  <XCircle size={20} className="mr-2" />
                  {isSubmitting && decision === false ? 'Enviando...' : 'No, la evidencia no es suficiente'}
                </div>
              </button>
              
              <button
                onClick={() => handleValidation(true)}
                disabled={isSubmitting}
                className={`flex-1 py-4 px-4 rounded-lg font-medium border-2 transition-all ${
                  isSubmitting 
                    ? 'bg-gray-100 text-gray-400 border-gray-200 cursor-not-allowed' 
                    : 'bg-green-50 text-green-700 border-green-200 hover:bg-green-100 hover:border-green-300'
                }`}
              >
                <div className="flex items-center justify-center">
                  <CheckCircle size={20} className="mr-2" />
                  {isSubmitting && decision === true ? 'Enviando...' : 'Sí, la acción ocurrió'}
                </div>
              </button>
            </div>

            <div className="mt-4 text-center">
              <p className="text-xs text-gray-500">
                Tu decisión será registrada y recompensada con ₭50
              </p>
            </div>
          </div>
        </Card>
      </div>
    </>
  );
}


//src/components/screens/ValorarAccionScreen.jsx

"use client";

import React, { useState, useEffect } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { CheckCircle, AlertCircle, Fish, Users, Globe } from 'lucide-react';
import Card from '@/components/ui/Card';
import FormField from '@/components/shared/FormField';
import MarkdownViewer from '@/components/shared/MarkdownViewer';
import { dataService } from '@/services/dataService';

export default function ValorarAccionScreen() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const actionId = searchParams?.get('action');
  
  const [valorationData, setValorationData] = useState(null);
  const [karmaValue, setKarmaValue] = useState('');
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  // Load valoration data on component mount
  useEffect(() => {
    if (actionId) {
      loadValorationData();
    }
  }, [actionId]);

  const loadValorationData = async () => {
    try {
      const data = await dataService.getValorationData(actionId);
      setValorationData(data);
    } catch (error) {
      console.error('Error loading valoration data:', error);
      setErrors({ load: 'Error al cargar los datos de la acción' });
    } finally {
      setIsLoading(false);
    }
  };

  // Handle karma input change
  const handleKarmaChange = (value) => {
    setKarmaValue(value);
    
    // Clear error when user starts typing
    if (errors.karma) {
      setErrors(prev => ({ ...prev, karma: '' }));
    }
  };

  // Validate form
  const validateForm = () => {
    const newErrors = {};
    
    if (!karmaValue.trim()) {
      newErrors.karma = 'Debe ingresar un valor de karma';
    } else {
      const numValue = parseFloat(karmaValue);
      if (isNaN(numValue)) {
        newErrors.karma = 'El valor debe ser un número válido';
      } else if (Math.abs(numValue) > 1000) {
        newErrors.karma = 'El valor debe estar entre -1000 y 1000';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);
    
    try {
      const submission = {
        accionId: valorationData.accion.id,
        minkaValorandoId: valorationData.minkaValorando.id,
        minkaAfectadaId: valorationData.minkaAfectada.id,
        karmaValue: parseFloat(karmaValue),
        userId: '1' // Current user Juan
      };
      
      const result = await dataService.submitKarmaValoration(submission);
      console.log('Valoration saved:', result);
      setShowSuccess(true);
      
      // Navigate back after success
      setTimeout(() => {
        router.push('/');
      }, 2000);
      
    } catch (error) {
      console.error('Error saving valoration:', error);
      setErrors({ submit: 'Error al guardar la valoración. Intenta nuevamente.' });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Show loading state
  if (isLoading) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-gray-600">Cargando información de la acción...</p>
        </Card>
      </div>
    );
  }

  // Show error state
  if (errors.load || !valorationData) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <AlertCircle size={48} className="text-red-500 mx-auto mb-4" />
          <h2 className="text-xl font-bold text-gray-800 mb-2">Error al cargar</h2>
          <p className="text-gray-600 mb-4">
            {errors.load || 'No se pudo cargar la información de la acción'}
          </p>
          <button
            onClick={() => router.back()}
            className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Volver
          </button>
        </Card>
      </div>
    );
  }

  // Calculate dynamic explanation values
  const karmaNum = parseFloat(karmaValue) || 0;
  const totalImpact = Math.abs(karmaNum * valorationData.minkaAfectada.miembros);
  const isPositive = karmaNum > 0;
  const isGlobal = valorationData.minkaAfectada.id === 'global';
  const isSameMinka = valorationData.minkaValorando.id === valorationData.minkaAfectada.id;

  // Success state
  if (showSuccess) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <CheckCircle size={48} className="text-green-500 mx-auto mb-4" />
          <h2 className="text-xl font-bold text-gray-800 mb-2">¡Valoración enviada!</h2>
          <p className="text-gray-600 mb-4">
            Tu valoración de <strong>{karmaValue} karma</strong> para la acción <strong>"{valorationData.accion.nombre}"</strong> ha sido registrada.
          </p>
          <p className="text-sm text-gray-500">
            Esta valoración será aplicada cuando alguien realice esta acción.
          </p>
        </Card>
      </div>
    );
  }

  return (
    <>
      {/* Title Card */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <h1 className="text-xl font-bold text-gray-800 mb-3">Valorar acción</h1>
            <p className="text-gray-700 text-sm leading-relaxed">
              Definí cuánto karma debería recibir alguien por realizar esta acción.
            </p>
          </div>
        </Card>
      </div>

      {/* Action Details */}
      <div className="px-4 pb-4">
        <Card>
          <div className="p-4">
            <div className="flex items-center mb-3">
              <Fish size={18} className="text-blue-600 mr-2" />
              <h3 className="font-medium text-gray-800">Acción a valorar</h3>
            </div>
            
            <div className="mb-4">
              <h4 className="font-bold text-gray-800 text-lg">{valorationData.accion.nombre}</h4>
              <div className="flex items-center mt-2 text-sm text-gray-600">
                <Users size={14} className="mr-1" />
                <span>Valorando desde: {valorationData.minkaValorando.nombre}</span>
                <span className="mx-2">•</span>
                {isGlobal ? (
                  <>
                    <Globe size={14} className="mr-1" />
                    <span>Afecta: Globalmente</span>
                  </>
                ) : (
                  <>
                    <Fish size={14} className="mr-1" />
                    <span>Afecta: {valorationData.minkaAfectada.nombre}</span>
                  </>
                )}
              </div>
            </div>

            <div className="bg-gray-50 rounded-lg p-4 max-h-40 overflow-y-auto">
              <MarkdownViewer content={valorationData.accion.descripcion} />
            </div>
          </div>
        </Card>
      </div>

      {/* Valoration Form */}
      <div className="px-4 pb-6">
        <Card className="p-6">
          <form onSubmit={handleSubmit}>
            {/* Question */}
            <div className="mb-6">
              <h3 className="font-medium text-gray-800 mb-4 text-lg">
                ¿Cuánto te afecta que alguien {!isSameMinka && !isGlobal && `de ${valorationData.minkaAfectada.nombre} `}
                haga la acción "{valorationData.accion.nombre}"?
              </h3>
            </div>

            {/* Karma Input */}
            <FormField
              label="Valor de karma"
              required
              error={errors.karma}
              description="Ingresá un número (puede tener decimales y ser negativo)"
            >
              <input
                type="number"
                step="0.1"
                value={karmaValue}
                onChange={(e) => handleKarmaChange(e.target.value)}
                placeholder="Ej: 12.5, -5, 0.3"
                className={`w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent ${
                  errors.karma ? 'border-red-500' : 'border-gray-300'
                }`}
              />
            </FormField>

            {/* Dynamic Explanation */}
            {karmaValue && !isNaN(parseFloat(karmaValue)) && (
              <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <h4 className="font-medium text-blue-800 mb-3">Estás proponiendo que:</h4>
                <div className="text-blue-700 text-sm space-y-2">
                  <p>
                    • Cuando alguien <strong>{!isGlobal && `de ${valorationData.minkaAfectada.nombre} `}</strong>
                    haga <strong>{valorationData.accion.nombre}</strong>,
                  </p>
                  <p>
                    • Cada miembro de <strong>{valorationData.minkaValorando.nombre}</strong> contribuya <strong>₭{karmaNum}</strong>
                  </p>
                  <p>
                    • Para <strong>{isPositive ? 'recompensarlo' : 'multarlo'}</strong> en <strong>₭{totalImpact.toLocaleString()}</strong>
                  </p>
                </div>
                
                <div className="mt-4 pt-3 border-t border-blue-300">
                  <p className="text-blue-800 font-medium">
                    En otras palabras, estarías dispuesto a pagar <strong>₭{Math.abs(karmaNum)}</strong> para que la acción 
                    <strong> {isPositive ? 'se haga' : 'no se haga'}</strong>.
                  </p>
                </div>
              </div>
            )}

            {/* Confirmation */}
            {karmaValue && !isNaN(parseFloat(karmaValue)) && (
              <div className="mb-6">
                <div className="flex items-center p-3 bg-gray-50 rounded-lg">
                  <input
                    type="checkbox"
                    id="confirm"
                    required
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded mr-3"
                  />
                  <label htmlFor="confirm" className="text-sm text-gray-700">
                    Estás de acuerdo con esta valoración
                  </label>
                </div>
              </div>
            )}

            {/* Submit Error */}
            {errors.submit && (
              <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg flex items-center">
                <AlertCircle size={18} className="text-red-500 mr-2" />
                <span className="text-red-700 text-sm">{errors.submit}</span>
              </div>
            )}

            {/* Submit Button */}
            <div className="flex gap-3">
              <button
                type="button"
                onClick={() => router.back()}
                className="flex-1 py-3 px-4 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 font-medium"
              >
                Cancelar
              </button>
              <button
                type="submit"
                disabled={isSubmitting || !karmaValue || isNaN(parseFloat(karmaValue))}
                className={`flex-1 py-3 px-4 rounded-lg font-medium text-white ${
                  isSubmitting || !karmaValue || isNaN(parseFloat(karmaValue))
                    ? 'bg-gray-400 cursor-not-allowed' 
                    : 'bg-blue-600 hover:bg-blue-700'
                }`}
              >
                {isSubmitting ? 'Enviando valoración...' : 'Enviar mi voto'}
              </button>
            </div>
          </form>
        </Card>
      </div>
    </>
  );
}


//src/components/screens/ValorarNuevaAccionScreen.jsx

"use client";

import React, { useState, useEffect } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { CheckCircle, AlertCircle, FileText, Users, Globe, X, Fish, Heart, Code, Car } from 'lucide-react';
import Card from '@/components/ui/Card';
import FormField from '@/components/shared/FormField';
import SearchInput from '@/components/shared/SearchInput';
import MarkdownViewer from '@/components/shared/MarkdownViewer';
import { dataService } from '@/services/dataService';

// Icon mapping
const iconMap = {
  Fish,
  Users,
  Globe,
  Heart,
  Code,
  Car,
  // Add more as needed
};

export default function ValorarNuevaAccionScreen() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const minkaId = searchParams?.get('minka') || 'pescadores';
  
  const [minka, setMinka] = useState(null);
  const [selectedAction, setSelectedAction] = useState(null);
  const [associatedMinka, setAssociatedMinka] = useState('');
  const [complement, setComplement] = useState(false);
  const [karmaValue, setKarmaValue] = useState('');
  const [availableMinkas, setAvailableMinkas] = useState([]);
  
  const [actionSearchResults, setActionSearchResults] = useState([]);
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadInitialData();
  }, [minkaId]);

  const loadInitialData = async () => {
    try {
      const [minkaData, availableMinkaData] = await Promise.all([
        dataService.getMinka(minkaId),
        dataService.getAvailableMinkas(minkaId)
      ]);
      
      setMinka(minkaData);
      setAvailableMinkas(availableMinkaData);
      
      // Set default associated minka to current minka
      setAssociatedMinka(minkaData.id);
    } catch (error) {
      console.error('Error loading data:', error);
      setErrors({ load: 'Error al cargar los datos' });
    } finally {
      setIsLoading(false);
    }
  };

  // Handle action search
  const handleActionSearch = async (query) => {
    try {
      const results = await dataService.searchActions(query);
      setActionSearchResults(results);
    } catch (error) {
      console.error('Error searching actions:', error);
      setActionSearchResults([]);
    }
  };

  const handleActionSelect = (action) => {
    setSelectedAction(action);
    setActionSearchResults([]);
    if (errors.action) {
      setErrors(prev => ({ ...prev, action: '' }));
    }
  };

  // Handle form changes
  const handleKarmaChange = (value) => {
    setKarmaValue(value);
    if (errors.karma) {
      setErrors(prev => ({ ...prev, karma: '' }));
    }
  };

  // Validate form
  const validateForm = () => {
    const newErrors = {};
    
    if (!selectedAction) {
      newErrors.action = 'Debe seleccionar una acción para valorar';
    }

    if (!associatedMinka) {
      newErrors.associatedMinka = 'Debe seleccionar a quién aplica la valoración';
    }
    
    if (!karmaValue.trim()) {
      newErrors.karma = 'Debe ingresar un valor de karma';
    } else {
      const numValue = parseFloat(karmaValue);
      if (isNaN(numValue)) {
        newErrors.karma = 'El valor debe ser un número válido';
      } else if (Math.abs(numValue) > 1000) {
        newErrors.karma = 'El valor debe estar entre -1000 y 1000';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);
    
    try {
      // Calculate total impact based on associated minka
      const targetMinka = availableMinkas.find(m => m.id === associatedMinka);
      let targetMembers = 1000; // Default for global
      
      if (targetMinka?.type === 'current') {
        targetMembers = minka.members;
      } else if (targetMinka?.type === 'sub') {
        // Get subminka member count (would need to fetch this)
        targetMembers = 50; // Placeholder
      }

      if (complement) {
        // For complement, it's the inverse (total - minka members)
        targetMembers = targetMembers > 100 ? targetMembers - 50 : targetMembers;
      }

      const valorationData = {
        minkaId: minka.id,
        actionId: selectedAction.id,
        associatedMinka: associatedMinka,
        complement: complement,
        karmaValue: parseFloat(karmaValue),
        totalImpact: Math.abs(parseFloat(karmaValue) * targetMembers)
      };
      
      const result = await dataService.submitKarmaValuation(valorationData);
      console.log('Valuation saved:', result);
      setShowSuccess(true);
      
      // Navigate back after success
      setTimeout(() => {
        router.push(`/minka/${minka.id}/valuations`);
      }, 2000);
      
    } catch (error) {
      console.error('Error saving valoration:', error);
      setErrors({ submit: 'Error al guardar la valoración. Intenta nuevamente.' });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Calculate dynamic explanation values
  const karmaNum = parseFloat(karmaValue) || 0;
  const isPositive = karmaNum > 0;

  // Show loading state
  if (isLoading) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-gray-600">Cargando...</p>
        </Card>
      </div>
    );
  }

  // Show error state
  if (errors.load || !minka) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <AlertCircle size={48} className="text-red-500 mx-auto mb-4" />
          <h2 className="text-xl font-bold text-gray-800 mb-2">Error al cargar</h2>
          <p className="text-gray-600 mb-4">
            {errors.load || 'No se pudo cargar la información de la minka'}
          </p>
          <button
            onClick={() => router.back()}
            className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Volver
          </button>
        </Card>
      </div>
    );
  }

  // Success state
  if (showSuccess) {
    return (
      <div className="m-4">
        <Card className="p-6 text-center">
          <CheckCircle size={48} className="text-green-500 mx-auto mb-4" />
          <h2 className="text-xl font-bold text-gray-800 mb-2">¡Valoración creada!</h2>
          <p className="text-gray-600 mb-4">
            <strong>{minka.name}</strong> ahora valora la acción <strong>"{selectedAction?.name}"</strong> en <strong>{karmaValue} karma</strong>.
          </p>
          <p className="text-sm text-gray-500">
            Esta valoración se aplicará cuando alguien realice esta acción.
          </p>
        </Card>
      </div>
    );
  }

  const MinkaIcon = iconMap[minka.icon] || iconMap.Users;

  return (
    <>
      {/* Title Card */}
      <div className="m-4">
        <Card>
          <div className="p-5">
            <div className="flex items-center mb-3">
              <div className="w-10 h-10 rounded-lg bg-blue-50 flex items-center justify-center mr-3">
                <MinkaIcon size={24} className={minka.iconColor || 'text-blue-600'} />
              </div>
              <div>
                <h1 className="text-xl font-bold text-gray-800">Valorar nueva acción</h1>
                <p className="text-gray-600 text-sm">para {minka.name}</p>
              </div>
            </div>
            <p className="text-gray-700 text-sm leading-relaxed">
              Definí cuánto karma debería pagar cada miembro de {minka.name} cuando alguien realice una acción específica.
            </p>
          </div>
        </Card>
      </div>

      {/* Form */}
      <div className="px-4 pb-6">
        <Card className="p-6">
          <form onSubmit={handleSubmit} className="space-y-6">
            
            {/* Action Selection */}
            <FormField
              label="Acción a valorar"
              required
              error={errors.action}
              description="Buscá y seleccioná la acción que querés que valora esta minka"
            >
              <SearchInput
                placeholder="Buscar acción por nombre..."
                onSearch={handleActionSearch}
                suggestions={actionSearchResults}
                onSelect={handleActionSelect}
                value={selectedAction ? selectedAction.name : ''}
                renderSuggestion={(action) => (
                  <div className="flex items-center">
                    <div className="w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center mr-3">
                      <FileText size={16} className="text-gray-600" />
                    </div>
                    <div className="flex-1">
                      <div className="font-medium text-gray-800">{action.name}</div>
                      <div className="text-sm text-gray-500">{action.description}</div>
                    </div>
                  </div>
                )}
              />
            </FormField>

            {/* Action Preview */}
            {selectedAction && (
              <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                <h4 className="font-medium text-gray-800 mb-2">Acción seleccionada:</h4>
                <div className="mb-2">
                  <div className="font-medium text-gray-800">{selectedAction.name}</div>
                  <div className="text-sm text-gray-600">{selectedAction.description}</div>
                </div>
              </div>
            )}

            {/* Associated Minka Selection */}
            <FormField
              label="¿A quién aplica?"
              required
              error={errors.associatedMinka}
              description="Seleccioná a qué grupo aplica esta valoración"
            >
              <div className="space-y-3">
                {availableMinkas.map((availableMinka) => {
                  const isSelected = associatedMinka === availableMinka.id;
                  let IconComponent = iconMap.Users;
                  let iconColor = 'text-blue-600';
                  
                  if (availableMinka.type === 'global') {
                    IconComponent = iconMap.Globe;
                    iconColor = 'text-green-600';
                  } else if (availableMinka.type === 'current') {
                    IconComponent = iconMap[minka.icon] || iconMap.Users;
                    iconColor = minka.iconColor || 'text-blue-600';
                  }
                  
                  return (
                    <label
                      key={availableMinka.id}
                      className={`flex items-center p-3 border-2 rounded-lg cursor-pointer transition-all ${
                        isSelected 
                          ? 'border-blue-500 bg-blue-50' 
                          : 'border-gray-300 hover:border-gray-400'
                      }`}
                    >
                      <input
                        type="radio"
                        name="associatedMinka"
                        value={availableMinka.id}
                        checked={isSelected}
                        onChange={(e) => setAssociatedMinka(e.target.value)}
                        className="sr-only"
                      />
                      <div className="w-8 h-8 rounded-lg bg-white border border-gray-300 flex items-center justify-center mr-3">
                        <IconComponent size={18} className={iconColor} />
                      </div>
                      <div>
                        <div className="font-medium text-gray-800">{availableMinka.name}</div>
                        <div className="text-sm text-gray-500">
                          {availableMinka.type === 'global' && 'Aplica a todos los usuarios'}
                          {availableMinka.type === 'current' && `Aplica a miembros de ${minka.name}`}
                          {availableMinka.type === 'sub' && `Aplica a miembros de ${availableMinka.name}`}
                        </div>
                      </div>
                    </label>
                  );
                })}
              </div>
            </FormField>

            {/* Complement Option */}
            {associatedMinka && associatedMinka !== 'global' && (
              <FormField
                label="Complemento"
                description="¿Querés aplicar la valoración al complemento (los que NO son de esta minka)?"
              >
                <label className="flex items-center p-3 bg-gray-50 rounded-lg cursor-pointer">
                  <input
                    type="checkbox"
                    checked={complement}
                    onChange={(e) => setComplement(e.target.checked)}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded mr-3"
                  />
                  <div>
                    <div className="font-medium text-gray-800">
                      Aplicar a NO-{availableMinkas.find(m => m.id === associatedMinka)?.name}
                    </div>
                    <div className="text-sm text-gray-600">
                      La valoración se aplicará a personas que NO sean de {availableMinkas.find(m => m.id === associatedMinka)?.name}
                    </div>
                  </div>
                </label>
              </FormField>
            )}

            {/* Karma Value Input */}
            <FormField
              label="Valor de karma"
              required
              error={errors.karma}
              description="¿Cuánto karma debería pagar cada miembro de la minka cuando ocurra esta acción?"
            >
              <input
                type="number"
                step="0.1"
                value={karmaValue}
                onChange={(e) => handleKarmaChange(e.target.value)}
                placeholder="Ej: 12.5, -5, 0.3"
                className={`w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent ${
                  errors.karma ? 'border-red-500' : 'border-gray-300'
                }`}
              />
            </FormField>

            {/* Dynamic Explanation */}
            {karmaValue && !isNaN(parseFloat(karmaValue)) && selectedAction && associatedMinka && (
              <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <h4 className="font-medium text-blue-800 mb-3">Estás definiendo que:</h4>
                <div className="text-blue-700 text-sm space-y-2">
                  <p>
                    • Cuando alguien {complement ? `que NO sea` : `de`} <strong>
                      {availableMinkas.find(m => m.id === associatedMinka)?.name}
                    </strong> haga <strong>"{selectedAction.name}"</strong>
                  </p>
                  <p>
                    • Cada miembro de <strong>{minka.name}</strong> {isPositive ? 'premiará' : 'multará'} con <strong>₭{Math.abs(karmaNum)}</strong>
                  </p>
                  <p>
                    • El impacto total será aproximadamente <strong>₭{Math.abs(karmaNum * minka.members).toLocaleString()}</strong>
                  </p>
                </div>
                
                <div className="mt-4 pt-3 border-t border-blue-300">
                  <p className="text-blue-800 font-medium">
                    En otras palabras, como miembro de {minka.name}, estarías dispuesto a pagar <strong>₭{Math.abs(karmaNum)}</strong> para que esta acción 
                    <strong> {isPositive ? 'se haga' : 'no se haga'}</strong>.
                  </p>
                </div>
              </div>
            )}

            {/* Confirmation */}
            {karmaValue && !isNaN(parseFloat(karmaValue)) && selectedAction && associatedMinka && (
              <div className="mb-6">
                <div className="flex items-center p-3 bg-gray-50 rounded-lg">
                  <input
                    type="checkbox"
                    id="confirm"
                    required
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded mr-3"
                  />
                  <label htmlFor="confirm" className="text-sm text-gray-700">
                    Confirmo que {minka.name} debe valorar esta acción con estos parámetros
                  </label>
                </div>
              </div>
            )}

            {/* Submit Error */}
            {errors.submit && (
              <div className="p-3 bg-red-50 border border-red-200 rounded-lg flex items-center">
                <AlertCircle size={18} className="text-red-500 mr-2" />
                <span className="text-red-700 text-sm">{errors.submit}</span>
              </div>
            )}

            {/* Submit Button */}
            <div className="flex gap-3">
              <button
                type="button"
                onClick={() => router.back()}
                className="flex-1 py-3 px-4 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 font-medium"
              >
                Cancelar
              </button>
              <button
                type="submit"
                disabled={isSubmitting || !selectedAction || !associatedMinka || !karmaValue || isNaN(parseFloat(karmaValue))}
                className={`flex-1 py-3 px-4 rounded-lg font-medium text-white ${
                  isSubmitting || !selectedAction || !associatedMinka || !karmaValue || isNaN(parseFloat(karmaValue))
                    ? 'bg-gray-400 cursor-not-allowed' 
                    : 'bg-blue-600 hover:bg-blue-700'
                }`}
              >
                {isSubmitting ? 'Guardando valoración...' : 'Crear valoración'}
              </button>
            </div>
          </form>
        </Card>
      </div>
    </>
  );
}


//src/components/shared/FormField.jsx


// src/components/shared/FormField.jsx
import React from 'react';

export default function FormField({ 
  label, 
  children, 
  error, 
  required = false,
  description,
  className = ""
}) {
  return (
    <div className={`mb-6 ${className}`}>
      <label className="block text-sm font-medium text-gray-700 mb-2">
        {label}
        {required && <span className="text-red-500 ml-1">*</span>}
      </label>
      {description && (
        <p className="text-sm text-gray-600 mb-3">{description}</p>
      )}
      {children}
      {error && (
        <p className="text-red-500 text-sm mt-1">{error}</p>
      )}
    </div>
  );
}


//src/components/shared/MarkdownEditor.jsx

// src/components/shared/MarkdownEditor.jsx
"use client";

import React, { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';

// Dynamically import the markdown editor to avoid SSR issues
const MDEditor = dynamic(
  () => import('@uiw/react-md-editor').then((mod) => mod.default),
  { 
    ssr: false,
    loading: () => (
      <div className="border border-gray-300 rounded-lg p-4 bg-gray-50">
        <div className="animate-pulse">
          <div className="h-4 bg-gray-200 rounded mb-2"></div>
          <div className="h-4 bg-gray-200 rounded mb-2 w-3/4"></div>
          <div className="h-4 bg-gray-200 rounded w-1/2"></div>
        </div>
      </div>
    )
  }
);

export default function MarkdownEditor({ value, onChange, placeholder, height = 200 }) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return (
      <div className="border border-gray-300 rounded-lg p-4 bg-gray-50" style={{ height }}>
        <div className="animate-pulse">
          <div className="h-4 bg-gray-200 rounded mb-2"></div>
          <div className="h-4 bg-gray-200 rounded mb-2 w-3/4"></div>
          <div className="h-4 bg-gray-200 rounded w-1/2"></div>
        </div>
      </div>
    );
  }

  return (
    <div className="markdown-editor">
      <MDEditor
        value={value}
        onChange={onChange}
        preview="edit"
        hideToolbar={false}
        textareaProps={{
          placeholder: placeholder || 'Escribí tu contenido en markdown...',
          style: { fontSize: 14, lineHeight: 1.5 }
        }}
        height={height}
      />
    </div>
  );
}




//src/components/shared/MarkdownViewer.jsx

// src/components/shared/MarkdownViewer.jsx
"use client";

import React from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

export default function MarkdownViewer({ content, className = "" }) {
  return (
    <div className={`prose prose-sm max-w-none ${className}`}>
      <ReactMarkdown 
        remarkPlugins={[remarkGfm]}
        components={{
          h1: ({node, ...props}) => <h1 className="text-xl font-bold text-gray-800 mb-3" {...props} />,
          h2: ({node, ...props}) => <h2 className="text-lg font-bold text-gray-800 mb-2 mt-4" {...props} />,
          h3: ({node, ...props}) => <h3 className="text-base font-bold text-gray-800 mb-2 mt-3" {...props} />,
          p: ({node, ...props}) => <p className="text-gray-700 mb-2 leading-relaxed" {...props} />,
          ul: ({node, ...props}) => <ul className="list-disc ml-4 mb-2 text-gray-700" {...props} />,
          ol: ({node, ...props}) => <ol className="list-decimal ml-4 mb-2 text-gray-700" {...props} />,
          li: ({node, ...props}) => <li className="mb-1" {...props} />,
          strong: ({node, ...props}) => <strong className="font-semibold text-gray-800" {...props} />,
          code: ({node, ...props}) => <code className="bg-gray-100 px-1 py-0.5 rounded text-sm font-mono" {...props} />,
          blockquote: ({node, ...props}) => <blockquote className="border-l-4 border-gray-300 pl-4 italic text-gray-600 my-3" {...props} />
        }}
      >
        {content || ''}
      </ReactMarkdown>
    </div>
  );
}




//src/components/shared/SearchInput.jsx

"use client";

import React, { useState, useRef, useEffect } from 'react';
import { Search, X } from 'lucide-react';

export default function SearchInput({ 
  placeholder, 
  onSearch, 
  suggestions = [], 
  onSelect,
  renderSuggestion,
  value = '',
  className = ""
}) {
  const [query, setQuery] = useState('');
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const inputRef = useRef(null);
  const suggestionsRef = useRef(null);

  // Only update internal query if external value changes and it's a string
  useEffect(() => {
    if (typeof value === 'string') {
      setQuery(value);
    }
  }, [value]);

  const handleInputChange = (e) => {
    const newQuery = e.target.value;
    setQuery(newQuery);
    setSelectedIndex(-1);
    onSearch(newQuery);
    setShowSuggestions(true);
  };

  const handleSelect = (suggestion, index) => {
    // Clear the input after selection
    setQuery('');
    setShowSuggestions(false);
    setSelectedIndex(-1);
    onSelect(suggestion);
  };

  const handleKeyDown = (e) => {
    if (!showSuggestions || suggestions.length === 0) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev < suggestions.length - 1 ? prev + 1 : 0
        );
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev > 0 ? prev - 1 : suggestions.length - 1
        );
        break;
      case 'Enter':
        e.preventDefault();
        if (selectedIndex >= 0) {
          handleSelect(suggestions[selectedIndex], selectedIndex);
        }
        break;
      case 'Escape':
        setShowSuggestions(false);
        setSelectedIndex(-1);
        break;
    }
  };

  const clearInput = () => {
    setQuery('');
    setShowSuggestions(false);
    onSearch('');
    onSelect(null);
    inputRef.current?.focus();
  };

  return (
    <div className={`relative ${className}`}>
      <div className="relative">
        <Search size={18} className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
        <input
          ref={inputRef}
          type="text"
          value={query}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          onFocus={() => setShowSuggestions(true)}
          onBlur={() => {
            // Delay hiding suggestions to allow for clicks
            setTimeout(() => setShowSuggestions(false), 200);
          }}
          placeholder={placeholder}
          className="w-full pl-10 pr-10 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        />
        {query && (
          <button
            onClick={clearInput}
            className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
          >
            <X size={18} />
          </button>
        )}
      </div>

      {showSuggestions && suggestions.length > 0 && (
        <div
          ref={suggestionsRef}
          className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto"
        >
          {suggestions.map((suggestion, index) => (
            <div
              key={suggestion.id || index}
              onClick={() => handleSelect(suggestion, index)}
              className={`px-4 py-3 cursor-pointer hover:bg-gray-50 ${
                index === selectedIndex ? 'bg-blue-50' : ''
              } ${index === suggestions.length - 1 ? '' : 'border-b border-gray-100'}`}
            >
              {renderSuggestion ? renderSuggestion(suggestion) : (
                <div>
                  <div className="font-medium text-gray-800">
                    {suggestion.name || suggestion.nombre}
                  </div>
                  {(suggestion.username || suggestion.resumen) && (
                    <div className="text-sm text-gray-500">
                      {suggestion.username || suggestion.resumen}
                    </div>
                  )}
                </div>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}



//src/components/ui/ActionButton.jsx

import React from 'react';

export default function ActionButton({ icon, label, bgColor, textColor, onClick }) {
  return (
    <div 
      className={`flex flex-col items-center ${onClick ? 'cursor-pointer' : ''}`}
      onClick={onClick}
    >
      <div className={`h-14 w-14 rounded-full ${bgColor} flex items-center justify-center mb-2 shadow-sm hover:shadow-md transition-shadow`}>
        {icon}
      </div>
      <span className="font-medium text-xs">{label}</span>
    </div>
  );
}



//src/components/ui/ActionItem.jsx

import React from 'react';

export default function ActionItem({ icon, label, highlight = false, onClick }) {
  return (
    <div 
      className={`flex items-center p-2 hover:bg-gray-50 rounded-lg ${onClick ? 'cursor-pointer' : ''}`}
      onClick={onClick}
    >
      <div className={`h-10 w-10 rounded-lg ${highlight ? 'bg-blue-100' : 'bg-gray-100'} flex items-center justify-center mr-3`}>
        {icon}
      </div>
      <span className={`text-sm ${highlight ? 'font-medium text-blue-700' : ''}`}>{label}</span>
    </div>
  );
}


//src/components/ui/ActionRow.jsx

// src/components/ui/ActionRow.jsx - Updated with valuation support
"use client";

import React from 'react';
import { useRouter } from 'next/navigation';
import { 
  Fish, 
  MapPin, 
  ShoppingBag, 
  Baby, 
  Globe, 
  Users, 
  Heart,
  Car,
  Code,
  FileText,
  X
} from 'lucide-react';

// Icon mapping
const iconMap = {
  Fish,
  MapPin,
  ShoppingBag,
  Baby,
  Globe,
  Users,
  Heart,
  Car,
  Code,
  FileText,
};

export default function ActionRow({ 
  action,
  valuation,
  minkaContext,
  onClick = null
}) {
  const router = useRouter();
  
  const handleClick = () => {
    if (onClick) {
      onClick();
    } else if (action?.id) {
      router.push(`/action/${action.id}?minka=${minkaContext?.id || 'pescadores'}`);
    }
  };

  if (!action || !valuation) {
    return null;
  }

  // Get action icon
  const ActionIcon = iconMap[action.icon] || FileText;
  
  // Determine scope icon and label based on valuation
  let ScopeIcon, scopeLabel, scopeIconColor;
  
  if (valuation.associatedMinka === 'global') {
    ScopeIcon = Globe;
    scopeLabel = 'Global';
    scopeIconColor = 'text-green-600';
  } else if (valuation.complement) {
    // For complement (non-X), show crossed icon
    const MinkaIcon = iconMap[minkaContext?.icon] || Users;
    ScopeIcon = ({ size, className }) => (
      <div className="relative">
        <MinkaIcon size={size} className={className} />
        <X size={size * 0.6} className="absolute top-0 left-0 text-red-500" />
      </div>
    );
    scopeLabel = `No ${valuation.associatedMinka}`;
    scopeIconColor = 'text-red-600';
  } else {
    // Regular minka
    const minka = minkaContext?.id === valuation.associatedMinka ? 
      minkaContext : 
      { icon: 'Users', iconColor: 'text-blue-600' }; // Default for other minkas
    
    ScopeIcon = iconMap[minka.icon] || Users;
    scopeLabel = valuation.associatedMinka;
    scopeIconColor = minka.iconColor || 'text-blue-600';
  }

  // Format valuation value
  let valueDisplay, valueColor;
  
  if (valuation.isExchange) {
    valueDisplay = `⇆ ${valuation.exchangePercentage}%`;
    valueColor = 'text-gray-600';
  } else {
    const isPositive = valuation.value >= 0;
    valueDisplay = `${isPositive ? '+' : ''}₭ ${Math.abs(valuation.value)}`;
    valueColor = isPositive ? 'text-green-600' : 'text-red-600';
  }

  const isClickable = action.id || onClick;
  
  return (
    <div 
      className={`p-4 border-b border-gray-100 last:border-b-0 ${isClickable ? 'hover:bg-gray-50 cursor-pointer' : ''}`}
      onClick={handleClick}
    >
      <div className="flex items-start justify-between">
        <div className="flex items-start flex-1 pr-4">
          <div className="w-8 h-8 flex items-center justify-center mr-3 mt-1">
            <ActionIcon size={18} className="text-gray-600" />
          </div>
          <div className="flex-1 max-w-xs">
            <div className="flex items-center justify-between mb-1">
              <div className="text-gray-800 font-medium">{action.name}</div>
              <div className="flex items-center ml-2">
                <div className="w-4 h-4 flex items-center justify-center mr-1">
                  <ScopeIcon size={14} className={scopeIconColor} />
                </div>
                <span className="text-xs text-gray-500">{scopeLabel}</span>
              </div>
            </div>
            {action.description && (
              <div className="text-sm text-gray-600 mt-1">
                {action.description.length > 45 ? `${action.description.substring(0, 45)}...` : action.description}
              </div>
            )}
          </div>
        </div>
        <div className="text-right">
          <div className={`font-medium text-lg ${valueColor}`}>{valueDisplay}</div>
          <div className="text-xs text-gray-500 mt-1">
            <div>Mi voto: {valuation.userValue >= 0 ? '+' : ''}₭{valuation.userValue}</div>
            <div>Mediana: {valuation.medianValue >= 0 ? '+' : ''}₭{valuation.medianValue}</div>
          </div>
        </div>
      </div>
    </div>
  );
}


//src/components/ui/Card.jsx

import React from 'react';

export default function Card({ children, className = "" }) {
  return (
    <div className={`bg-white rounded-xl shadow-sm ${className}`}>
      {children}
    </div>
  );
}




//src/components/ui/CaseItem.jsx


import React from 'react';

export default function CaseItem({ name, time, date, value, isPositive = true }) {
  const valueColor = isPositive ? 'text-green-600' : 'text-red-600';
  
  return (
    <div className="flex items-center justify-between p-3 border-b border-gray-100 last:border-b-0">
      <div className="flex-1">
        <div className="font-medium text-gray-800">{name}</div>
        <div className="text-xs text-gray-500">{time} {date}</div>
      </div>
      <div className={`font-medium ${valueColor}`}>
        {isPositive ? '+' : '-'}{value}
      </div>
    </div>
  );
}


//src/components/ui/CreateMinkaButton.jsx

import React from 'react';
import { Plus } from 'lucide-react';

export default function CreateMinkaButton({ label, onClick }) {
  return (
    <div 
      className="flex items-center justify-center p-4 bg-white rounded-xl shadow-sm border-2 border-dashed border-gray-300 hover:border-blue-300 cursor-pointer"
      onClick={onClick}
    >
      <Plus size={20} className="text-gray-500 mr-2" />
      <span className="text-gray-600 font-medium">{label}</span>
    </div>
  );
}


//src/components/ui/GradientCard.jsx

import React from 'react';

export default function GradientCard({ children, gradient, className = "" }) {
  return (
    <div className={`rounded-xl shadow-sm overflow-hidden ${gradient} ${className}`}>
      {children}
    </div>
  );
}


//src/components/ui/Header.jsx

"use client";

import React from 'react';
import { Menu, HelpCircle, Bell, ArrowLeft } from 'lucide-react';
import { useRouter } from 'next/navigation';
import { theme } from '@/styles/theme';

export default function Header({ showBackButton = false }) {
  const router = useRouter();

  const handleBackClick = () => {
    router.back();
  };

  return (
    <div className={`${theme.gradients.primary} text-white shadow-md`}>
      <div className="flex justify-between items-center p-4">
        {showBackButton ? (
          <ArrowLeft size={24} onClick={handleBackClick} className="cursor-pointer" />
        ) : (
          <Menu size={24} />
        )}
        <div className="flex items-center">
          <div 
            className="font-bold text-xl cursor-pointer" 
            onClick={() => router.push('/')}
          >
            Minkado
          </div>
        </div>
        <div className="flex items-center">
          <HelpCircle size={20} className="mr-3 opacity-80" />
          <div className="relative">
            <Bell size={20} className="opacity-80" />
            <div className="absolute -top-1 -right-1 bg-red-500 rounded-full w-3 h-3"></div>
          </div>
        </div>
      </div>
    </div>
  );
}


//src/components/ui/ListItem.jsx

import React from 'react';
import { useRouter } from 'next/navigation';

export default function ListItem({ 
  icon, 
  title, 
  subtitle, 
  value, 
  isPositive = false,
  indentLevel = 0,
  isTotal = false,
  minkaId = null, // Add this prop for navigation
  onClick = null // Allow custom click handlers
}) {
  const router = useRouter();
  
  // Calculate padding based on indent level
  const paddingLeft = indentLevel === 0 ? "" : 
                      indentLevel === 1 ? "pl-10" : 
                      indentLevel === 2 ? "pl-16" : "";
  
  const valueColor = isPositive ? 'text-green-500' : 'text-red-500';
  
  const handleClick = () => {
    if (onClick) {
      onClick();
    } else if (minkaId && !isTotal) {
      // Navigate to the minka detail page using the minkaId
      router.push(`/${minkaId.toLowerCase()}`);
    }
  };

  const isClickable = (minkaId && !isTotal) || onClick;
  
  return (
    <div 
      className={`p-4 border-b border-gray-100 flex items-center ${isClickable ? 'hover:bg-gray-50 cursor-pointer' : ''} ${paddingLeft} ${isTotal ? 'bg-gradient-to-r from-blue-50 to-green-50' : ''}`}
      onClick={handleClick}
    >
      {icon && (
        <div className="mr-3">
          {icon}
        </div>
      )}
      <div className="flex-1">
        <div className={`font-medium text-gray-800 ${isTotal ? 'font-bold' : ''}`}>{title}</div>
        {subtitle && <div className="text-xs text-gray-500">{subtitle}</div>}
      </div>
      <div className={`font-medium ${isTotal ? 'font-bold text-green-600' : valueColor}`}>
        {isPositive ? '+ ' : '- '}{value}
      </div>
    </div>
  );
}


//src/components/ui/MinkaListItem.jsx

// src/components/ui/MinkaListItem.jsx - Updated with onClick support
import React from 'react';

export default function MinkaListItem({ 
  icon, 
  title, 
  subtitle, 
  value, 
  isPositive = false,
  isMember = true,
  onClick
}) {
  const valueColor = isPositive ? 'text-green-500' : 'text-red-500';
  const textOpacity = isMember ? '' : 'opacity-50';
  
  return (
    <div 
      className={`p-4 border-b border-gray-100 flex items-center hover:bg-gray-50 last:border-b-0 ${textOpacity} ${onClick ? 'cursor-pointer' : ''}`}
      onClick={onClick}
    >
      <div className="mr-3">
        {icon}
      </div>
      <div className="flex-1">
        <div className="font-medium text-gray-800">{title}</div>
        <div className="text-xs text-gray-500">{subtitle}</div>
      </div>
      <div className={`font-medium ${valueColor}`}>
        {isPositive ? '+ ' : '- '}{value}
      </div>
    </div>
  );
}

// src/utils/navigation.js - Navigation utilities
export const navigationUtils = {
  goToMinka: (router, minkaId) => router.push(`/minka/${minkaId}`),
  goToAction: (router, actionId) => router.push(`/action/${actionId}`),
  goToCreateMinka: (router, parentId = null) => {
    const url = parentId ? `/crear-minka?parent=${parentId}` : '/crear-minka';
    router.push(url);
  },
  goToValorarAccion: (router, actionId) => router.push(`/valorar-accion?action=${actionId}`),
  goHome: (router) => router.push('/'),
};


//src/components/ui/MovementItem.jsx

import React from 'react';

export default function MovementItem({ 
  transactionText,
  amount,
  isPositive,
  scopeIcon,
  scopeLabel,
  percentage,
  scopePosition = "right",
  alignment = "right", // "left" or "right" for chat-like positioning
  timestamp
}) {
  const amountColor = isPositive ? 'text-green-600' : 'text-red-600';
  const sign = isPositive ? '+' : '-';
  
  // Different colors based on alignment (like chat messages). 
  // Right: My devolutions to others' actions
  // Left: Others' devolutions to my actions
  
  const bgColor = alignment === "right" ? "bg-blue-50" : "bg-gray-50";
  const containerClass = alignment === "right" ? "ml-8" : "mr-8";
  
  return (
    <div className={`mb-3 ${containerClass}`}>
      <div className={`${bgColor} rounded-xl p-4 shadow-sm`}>
        {/* Community info at top */}
        <div className={`flex ${scopePosition === 'left' ? 'justify-start' : 'justify-end'} mb-2`}>
          {scopeIcon && (
            <div className="flex items-center">
              <div className="w-4 h-4 flex items-center justify-center mr-1">
                {scopeIcon}
              </div>
              <span className="text-xs text-gray-500">{scopeLabel}</span>
            </div>
          )}
        </div>
        
        {/* Main content */}
        <div className="flex items-start justify-between mb-2">
          <div className="flex-1 pr-4">
            <div className="text-gray-800 font-medium mb-1">
              <span className="font-bold">{transactionText}</span>
            </div>
            {percentage && (
              <div className="text-sm text-gray-600 mt-1">
                {percentage}
              </div>
            )}
          </div>
          <div className="text-right">
            <div className={`font-medium text-lg ${amountColor}`}>
              {sign}₭{amount}
            </div>
          </div>
        </div>
        
        {/* Timestamp */}
        <div className="flex justify-end">
          <span className="text-xs text-gray-400">{timestamp}</span>
        </div>
      </div>
    </div>
  );
}


//src/components/ui/SectionTitle.jsx

import React from 'react';
import { theme } from '@/styles/theme';

export default function SectionTitle({ title, actionText, onAction }) {
  return (
    <div className="px-4 py-3 flex items-center justify-between">
      <h2 className="font-bold text-gray-800 text-lg">{title}</h2>
      {actionText && (
        <div 
          className={`text-sm ${theme.colors.primary.text} cursor-pointer`}
          onClick={onAction}
        >
          {actionText}
        </div>
      )}
    </div>
  );
}


//src/components/ui/ValuationChart.jsx

"use client";

import React from 'react';
import { useRouter } from 'next/navigation';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, ResponsiveContainer, Tooltip } from 'recharts';

// Custom Tooltip Component
function CustomTooltip({ active, payload, label }) {
  if (active && payload && payload.length) {
    const data = payload[0].payload;
    return (
      <div className="bg-white p-2 border border-gray-200 rounded-lg shadow-lg text-xs">
        <p className="font-medium text-gray-800">
          Valor: {payload[0].value >= 0 ? '+' : ''}₭{payload[0].value}
        </p>
        {data.isYo && <p className="text-purple-600 font-medium">Tu valoración</p>}
        {data.isMediana && <p className="text-gray-600 font-medium">Valoración mediana</p>}
      </div>
    );
  }
  return null;
}

// Custom Tooltip for Time Charts
function TimeTooltip({ active, payload, label }) {
  if (active && payload && payload.length) {
    return (
      <div className="bg-white p-2 border border-gray-200 rounded-lg shadow-lg text-xs">
        <p className="font-medium text-gray-600 mb-1">Año: {label}</p>
        {payload.map((entry, index) => (
          <p key={index} style={{ color: entry.color }} className="font-medium">
            {entry.dataKey === 'personal' ? 'Tu valoración' : 
             entry.dataKey === 'median' ? 'Mediana' : 'Impacto'}: 
            +₭{entry.value}
          </p>
        ))}
      </div>
    );
  }
  return null;
}

export default function ValuationChart({ 
  title, 
  currentValue, 
  avgValue, 
  totalImpact, 
  showTimeChart = false, 
  showValuationInfo = true,
  chartData = null,
  actionId = null
}) {
  const router = useRouter();

  const handleModificar = () => {
    if (actionId) {
      router.push(`/valorar-accion?action=${actionId}`);
    }
  };

  if (!showTimeChart) {
    // Current valuation chart - 21 hardcoded points, monotonically growing
    const data = [
      { index: 0, value: -5 },
      { index: 1, value: -3 },
      { index: 2, value: -1 },
      { index: 3, value: 1 },
      { index: 4, value: 3 },
      { index: 5, value: 5 },
      { index: 6, value: 7 },
      { index: 7, value: 8 },
      { index: 8, value: 9 },
      { index: 9, value: 10, isMediana: true }, // Median point
      { index: 10, value: 11 },
      { index: 11, value: 12, isYo: true }, // Your valuation point
      { index: 12, value: 13 },
      { index: 13, value: 14 },
      { index: 14, value: 15 },
      { index: 15, value: 17 },
      { index: 16, value: 19 },
      { index: 17, value: 21 },
      { index: 18, value: 22 },
      { index: 19, value: 23 },
      { index: 20, value: 25 }
    ];

    // Custom dot component to highlight specific points
    const CustomDot = (props) => {
      const { cx, cy, payload } = props;
      if (payload.isYo) {
        return (
          <g>
            <circle cx={cx} cy={cy} r={4} fill="#8b5cf6" stroke="#8b5cf6" strokeWidth={2} />
            <text x={cx} y={cy - 12} fontSize="10" fill="#8b5cf6" textAnchor="middle" fontWeight="600">
              Yo: +₭{payload.value}
            </text>
          </g>
        );
      }
      if (payload.isMediana) {
        return (
          <g>
            <circle cx={cx} cy={cy} r={4} fill="#374151" stroke="#374151" strokeWidth={2} />
            <text x={cx} y={cy + 18} fontSize="10" fill="#6b7280" textAnchor="middle" fontWeight="500">
              Mediana: +₭{payload.value}
            </text>
          </g>
        );
      }
      return null;
    };

    return (
      <div className="p-4 bg-gray-50 rounded-lg mb-4">
        <div className="text-center mb-3">
          <h4 className="font-medium text-gray-800">{title}</h4>
        </div>
        
        <div className="h-32 mb-4">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={data} margin={{ top: 15, right: 5, left: 5, bottom: 25 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
              <XAxis 
                dataKey="index"
                axisLine={false}
                tickLine={false}
                tick={false}
              />
              <YAxis 
                domain={[-5, 25]}
                axisLine={false}
                tickLine={false}
                tick={false}
                width={0}
              />
              <Tooltip content={<CustomTooltip />} />
              <Line 
                type="monotone" 
                dataKey="value" 
                stroke="#374151" 
                strokeWidth={2}
                dot={<CustomDot />}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
        
        {showValuationInfo && (
          <div className="space-y-2 text-sm">
            <div className="grid grid-cols-3 items-center">
              <span className="text-gray-600">Mi valoración:</span>
              <span className="font-medium text-gray-800 text-right">{currentValue}</span>
              <span 
                className={`text-right ${actionId ? 'text-blue-600 underline cursor-pointer' : 'text-gray-400'}`}
                onClick={actionId ? handleModificar : undefined}
              >
                Modificar
              </span>
            </div>
            <div className="grid grid-cols-3 items-center">
              <span className="text-gray-600">Valoración mediana:</span>
              <span className="font-medium text-gray-800 text-right">{avgValue}</span>
              <span></span>
            </div>
            <div className="grid grid-cols-3 items-center">
              <span className="text-gray-600">Impacto total:</span>
              <span className="font-medium text-gray-800 text-right">{totalImpact}</span>
              <span></span>
            </div>
          </div>
        )}
      </div>
    );
  } else {
    // Time-based charts
    const personalData = [
      { year: 2023, value: 10 },
      { year: 2023.2, value: 10.2 },
      { year: 2023.4, value: 10.5 },
      { year: 2023.6, value: 10.8 },
      { year: 2023.8, value: 11.0 },
      { year: 2024, value: 11.3 },
      { year: 2024.2, value: 11.5 },
      { year: 2024.4, value: 11.7 },
      { year: 2024.6, value: 11.8 },
      { year: 2024.8, value: 11.9 },
      { year: 2025, value: 12 }
    ];

    const medianData = [
      { year: 2023, value: 8 },
      { year: 2023.2, value: 8.1 },
      { year: 2023.4, value: 8.3 },
      { year: 2023.6, value: 8.6 },
      { year: 2023.8, value: 8.9 },
      { year: 2024, value: 9.2 },
      { year: 2024.2, value: 9.4 },
      { year: 2024.4, value: 9.6 },
      { year: 2024.6, value: 9.7 },
      { year: 2024.8, value: 9.8 },
      { year: 2025, value: 10 }
    ];

    const impactData = [
      { year: 2023, value: 100 },
      { year: 2023.2, value: 120 },
      { year: 2023.4, value: 145 },
      { year: 2023.6, value: 175 },
      { year: 2023.8, value: 210 },
      { year: 2024, value: 250 },
      { year: 2024.2, value: 295 },
      { year: 2024.4, value: 345 },
      { year: 2024.6, value: 400 },
      { year: 2024.8, value: 450 },
      { year: 2025, value: 500 }
    ];

    // Combine personal and median data for dual-line chart
    const combinedData = personalData.map((item, index) => ({
      year: item.year,
      personal: item.value,
      median: medianData[index]?.value || 0
    }));

    return (
      <div className="p-4 bg-gray-50 rounded-lg mb-4">
        <div className="text-center mb-3">
          <h4 className="font-medium text-gray-800">{title}</h4>
        </div>
        
        <div className="space-y-4">
          {/* Legend for the dual-line chart */}
          <div className="flex justify-center space-x-4 text-xs">
            <div className="flex items-center">
              <div className="w-3 h-0.5 bg-purple-500 mr-1"></div>
              <span className="text-gray-600">Tu valoración</span>
            </div>
            <div className="flex items-center">
              <div className="w-3 h-0.5 bg-gray-600 mr-1"></div>
              <span className="text-gray-600">Mediana</span>
            </div>
          </div>

          <div className="h-24">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={combinedData} margin={{ top: 5, right: 5, left: 5, bottom: 20 }}>
                <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                <XAxis 
                  dataKey="year" 
                  type="number"
                  scale="linear"
                  domain={[2023, 2025]}
                  ticks={[2023, 2025]}
                  axisLine={false}
                  tickLine={false}
                  tick={{ fontSize: 10, fill: '#6b7280' }}
                />
                <YAxis 
                  axisLine={false}
                  tickLine={false}
                  tick={false}
                  width={0}
                />
                <Tooltip content={<TimeTooltip />} />
                <Line 
                  type="monotone" 
                  dataKey="personal" 
                  stroke="#8b5cf6" 
                  strokeWidth={2}
                  dot={false}
                />
                <Line 
                  type="monotone" 
                  dataKey="median" 
                  stroke="#6b7280" 
                  strokeWidth={1}
                  dot={false}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>

          <div className="text-center mb-2">
            <h5 className="font-medium text-gray-700 text-sm">Impacto total en el tiempo</h5>
          </div>

          <div className="h-24">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={impactData} margin={{ top: 5, right: 5, left: 5, bottom: 20 }}>
                <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                <XAxis 
                  dataKey="year" 
                  type="number"
                  scale="linear"
                  domain={[2023, 2025]}
                  ticks={[2023, 2025]}
                  axisLine={false}
                  tickLine={false}
                  tick={{ fontSize: 10, fill: '#6b7280' }}
                />
                <YAxis 
                  axisLine={false}
                  tickLine={false}
                  tick={false}
                  width={0}
                />
                <Tooltip content={<TimeTooltip />} />
                <Line 
                  type="monotone" 
                  dataKey="value" 
                  stroke="#374151" 
                  strokeWidth={3}
                  dot={false}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </div>
      </div>
    );
  }
}


//src/data/index.js

import movementsData from './json/movements.json';
import usersData from './json/users.json';
import minkasData from './json/minkas.json';
import actionsData from './json/actions.json';
import valuationsData from './json/valuations.json';
import reportsData from './json/reports.json';
import pactsData from './json/pacts.json';
import recentCasesData from './json/recentCases.json';

// Export all data arrays
export const mockMovements = movementsData.movements;
export const mockUsers = usersData.users;
export const mockMinkas = minkasData.minkas;
export const mockActions = actionsData.actions;
export const mockValuations = valuationsData.valuations;
export const mockReports = reportsData.reports;
export const mockPacts = pactsData.pacts;
export const mockUserMinkas = usersData.userMinkas;
export const mockRecentCases = recentCasesData.recentCases;

// Helper functions
export const getUsers = () => mockUsers;
export const getActions = () => mockActions;
export const getReports = () => mockReports;
export const getMinkas = () => mockMinkas;
export const getValuations = () => mockValuations;

export const getUserById = (id) => mockUsers.find(user => user.id === id);
export const getActionById = (id) => mockActions.find(action => action.id === id);
export const getReportById = (id) => mockReports.find(report => report.id === id);
export const getMinkaById = (id) => mockMinkas.find(minka => minka.id === id);

// Get recent cases for an action
export const getRecentCases = (actionId) => {
  return mockRecentCases[actionId] || [];
};

// Get valuations for a specific minka
export const getMinkaValuations = (minkaId) => {
  return mockValuations[minkaId] || [];
};

// Get a specific valuation for an action by a minka
export const getActionValuation = (minkaId, actionId) => {
  const minkaValuations = getMinkaValuations(minkaId);
  return minkaValuations.find(v => v.actionId === actionId);
};

// Get actions with their valuations for a specific minka
export const getActionsWithValuations = (minkaId) => {
  const minkaValuations = getMinkaValuations(minkaId);
  return minkaValuations.map(valuation => {
    const action = getActionById(valuation.actionId);
    return {
      ...action,
      valuation: valuation
    };
  });
};

export const searchUsers = (query) => {
  if (!query) return [];
  const lowQuery = query.toLowerCase();
  return mockUsers.filter(user => 
    user.name.toLowerCase().includes(lowQuery) ||
    user.username.toLowerCase().includes(lowQuery)
  );
};

export const searchActions = (query) => {
  if (!query) return [];
  const lowQuery = query.toLowerCase();
  return mockActions.filter(action => 
    action.name.toLowerCase().includes(lowQuery) ||
    action.description.toLowerCase().includes(lowQuery)
  );
};

export const getUserMinkas = (userId) => {
  const userMinkaIds = mockUserMinkas[userId] || [];
  return mockMinkas.filter(minka => userMinkaIds.includes(minka.id));
};

export const getMinkaActions = (minkaId) => {
  // Return actions with their valuations for this minka
  return getActionsWithValuations(minkaId);
};

export const getSubMinkas = (minkaId) => {
  const minka = getMinkaById(minkaId);
  if (!minka || !minka.subMinkas) return [];
  return mockMinkas.filter(m => minka.subMinkas.includes(m.id));
};

// Save functions (these modify the in-memory data)
export const saveAction = (actionData) => {
  const newAction = {
    ...actionData,
    id: `action-${Date.now()}`,
    name: actionData.nombre,
    description: actionData.resumen,
    icon: 'FileText',
    createdAt: new Date().toISOString(),
    createdBy: 'juan.mk'
  };
  mockActions.push(newAction);
  return newAction;
};

export const saveReport = (reportData) => {
  const newReport = {
    ...reportData,
    id: `report-${Date.now()}`,
    status: 'pending',
    createdAt: new Date().toISOString(),
    validationReward: '₭50'
  };
  mockReports.push(newReport);
  return newReport;
};

export const validateReport = (reportId, isValid, validatorId) => {
  const report = getReportById(reportId);
  if (report) {
    report.status = isValid ? 'validated' : 'rejected';
    report.validatedBy = validatorId;
    report.validatedAt = new Date().toISOString();
  }
  return report;
};

// Save new valuation for a minka
export const saveValuation = (minkaId, actionId, valuationData) => {
  if (!mockValuations[minkaId]) {
    mockValuations[minkaId] = [];
  }
  
  // Remove existing valuation for this action if it exists
  mockValuations[minkaId] = mockValuations[minkaId].filter(v => v.actionId !== actionId);
  
  // Add new valuation
  const newValuation = {
    actionId,
    associatedMinka: valuationData.associatedMinka,
    complement: valuationData.complement || false,
    value: valuationData.value,
    medianValue: valuationData.value, // For now, set median same as value
    totalImpact: valuationData.totalImpact,
    userValue: valuationData.value
  };
  
  mockValuations[minkaId].push(newValuation);
  return newValuation;
};

// Additional exports for compatibility with existing code
export { mockUsers as users };
export { mockActions as actions };
export { mockReports as reports };
export { mockMinkas as minkas };
export { mockMovements as movements };
export { mockPacts as pacts };
export { mockValuations as valuations };
export { mockRecentCases as recentCases };

// Default export for convenience
export default {
  users: mockUsers,
  actions: mockActions,
  reports: mockReports,
  minkas: mockMinkas,
  movements: mockMovements,
  pacts: mockPacts,
  valuations: mockValuations,
  userMinkas: mockUserMinkas,
  recentCases: mockRecentCases,
  // Functions
  getUserById,
  getActionById,
  getReportById,
  getMinkaById,
  getMinkaValuations,
  getActionValuation,
  getActionsWithValuations,
  searchUsers,
  searchActions,
  getUserMinkas,
  getMinkaActions,
  getSubMinkas,
  saveAction,
  saveReport,
  validateReport,
  saveValuation,
  getRecentCases
};


//src/services/dataService.js

// src/services/dataService.js
import { 
  mockUsers, 
  mockActions, 
  mockReports,
  mockMinkas,
  mockMovements,
  mockUserMinkas,
  mockValuations,
  mockRecentCases,
  searchUsers as mockSearchUsers,
  searchActions as mockSearchActions,
  getUserMinkas as mockGetUserMinkas,
  getMinkaActions as mockGetMinkaActions,
  getSubMinkas as mockGetSubMinkas,
  saveAction as mockSaveAction,
  saveReport as mockSaveReport,
  validateReport as mockValidateReport,
  getMinkaValuations as mockGetMinkaValuations,
  getActionValuation as mockGetActionValuation,
  getActionsWithValuations as mockGetActionsWithValuations,
  saveValuation as mockSaveValuation,
  getUserById,
  getActionById,
  getRecentCases
} from '@/data';

class DataService {
  constructor(useMockData = true) {
    this.useMockData = useMockData;
    // In the future, initialize API client here
  }

  // Minka related methods
  async getMinkas() {
    if (this.useMockData) {
      return mockMinkas;
    }
    // return await api.get('/minkas');
  }

  async getMinka(minkaId) {
    if (this.useMockData) {
      return mockMinkas.find(m => m.id === minkaId);
    }
    // return await api.get(`/minkas/${minkaId}`);
  }

  async getUserMinkas(userId) {
    if (this.useMockData) {
      return mockGetUserMinkas(userId);
    }
    // return await api.get(`/users/${userId}/minkas`);
  }

  async getSubMinkas(minkaId) {
    if (this.useMockData) {
      return mockGetSubMinkas(minkaId);
    }
    // return await api.get(`/minkas/${minkaId}/subminkas`);
  }

  // Action related methods (pure actions without valuations)
  async getActions() {
    if (this.useMockData) {
      return mockActions;
    }
    // return await api.get('/actions');
  }

  async getAction(actionId) {
    if (this.useMockData) {
      // Find the action in the basic actions array
      const action = getActionById(actionId);
      if (!action) return null;
      
      // Add recent cases if available
      const recentCases = getRecentCases(actionId);
      
      return {
        ...action,
        fullDescription: `# ${action.name}\n\n${action.description}`,
        recentCases: recentCases
      };
    }
    // return await api.get(`/actions/${actionId}`);
  }

  // Valuation related methods
  async getMinkaValuations(minkaId) {
    if (this.useMockData) {
      return mockGetMinkaValuations(minkaId);
    }
    // return await api.get(`/minkas/${minkaId}/valuations`);
  }

  async getActionValuation(minkaId, actionId) {
    if (this.useMockData) {
      return mockGetActionValuation(minkaId, actionId);
    }
    // return await api.get(`/minkas/${minkaId}/valuations/${actionId}`);
  }

  async getActionsWithValuations(minkaId) {
    if (this.useMockData) {
      return mockGetActionsWithValuations(minkaId);
    }
    // return await api.get(`/minkas/${minkaId}/actions-with-valuations`);
  }

  async getMinkaActions(minkaId) {
    if (this.useMockData) {
      return mockGetMinkaActions(minkaId);
    }
    // return await api.get(`/minkas/${minkaId}/actions`);
  }

  async searchActions(query) {
    if (this.useMockData) {
      return mockSearchActions(query);
    }
    // return await api.get(`/actions/search?q=${query}`);
  }

  // User related methods
  async getUsers() {
    if (this.useMockData) {
      return mockUsers;
    }
    // return await api.get('/users');
  }

  async getUser(userId) {
    if (this.useMockData) {
      return mockUsers.find(u => u.id === userId);
    }
    // return await api.get(`/users/${userId}`);
  }

  async getCurrentUser() {
    if (this.useMockData) {
      // Hardcoded for now - Juan
      return {
        id: '1',
        name: 'Juan',
        username: 'juan.mk',
        balance: 26950.81,
        lastChange: 25
      };
    }
    // return await api.get('/users/me');
  }

  async searchUsers(query) {
    if (this.useMockData) {
      return mockSearchUsers(query);
    }
    // return await api.get(`/users/search?q=${query}`);
  }

  // Report related methods
  async getReports(filters = {}) {
    if (this.useMockData) {
      let reports = [...mockReports];
      
      if (filters.status) {
        reports = reports.filter(r => r.status === filters.status);
      }
      
      if (filters.actorId) {
        reports = reports.filter(r => r.actorId === filters.actorId);
      }
      
      return reports;
    }
    // return await api.get('/reports', { params: filters });
  }

  async createReport(reportData) {
    if (this.useMockData) {
      return mockSaveReport(reportData);
    }
    // return await api.post('/reports', reportData);
  }

  async validateReport(reportId, isValid, validatorId) {
    if (this.useMockData) {
      return mockValidateReport(reportId, isValid, validatorId);
    }
    // return await api.post(`/reports/${reportId}/validate`, { isValid, validatorId });
  }

  // Movement/Transaction methods
  async getUserMovements(userId) {
    if (this.useMockData) {
      return mockMovements.filter(m => m.userId === userId);
    }
    // return await api.get(`/users/${userId}/movements`);
  }

  // Action creation
  async saveAction(actionData) {
    if (this.useMockData) {
      return mockSaveAction(actionData);
    }
    // return await api.post('/actions', actionData);
  }

  // Pact related methods
  async createPact(pactData) {
    if (this.useMockData) {
      const newPact = {
        id: Date.now().toString(),
        ...pactData,
        status: 'proposed',
        createdAt: new Date().toISOString()
      };
      // In a real implementation, we would save this to the mock data
      return newPact;
    }
    // return await api.post('/pacts', pactData);
  }

  // Transfer methods
  async createTransfer(transferData) {
    if (this.useMockData) {
      const toUser = getUserById(transferData.toUserId);
      const newMovement = {
        id: Date.now().toString(),
        userId: transferData.fromUserId,
        type: 'transfer',
        text: `₭${Math.abs(transferData.amount)} ${transferData.amount > 0 ? 'a' : 'para penalizar a'} ${toUser?.name || 'Usuario'}`,
        amount: Math.abs(transferData.amount),
        isPositive: false,
        scopeIcon: 'User',
        scopeLabel: 'Particular',
        reason: transferData.motivo,
        alignment: 'right',
        timestamp: new Date().toLocaleTimeString('es-AR', { hour: '2-digit', minute: '2-digit' }),
        date: new Date().toISOString().split('T')[0],
        fromUserId: transferData.fromUserId,
        toUserId: transferData.toUserId
      };
      
      // Add to movements array
      mockMovements.push(newMovement);
      
      return {
        success: true,
        movement: newMovement
      };
    }
    // return await api.post('/transfers', transferData);
  }

  // Additional helper methods for specific screens
  async getActionWithDetails(actionId) {
    if (this.useMockData) {
      // Just use getAction since it now includes everything
      return this.getAction(actionId);
    }
    // return await api.get(`/actions/${actionId}/full`);
  }

  // Mock data for CrearMinkaScreen
  async getUserMinkasForCreation(userId) {
    if (this.useMockData) {
      // Return minkas where user is member for selecting parent minka
      const userMinkas = await this.getUserMinkas(userId);
      return userMinkas.map(minka => ({
        id: minka.id,
        nombre: minka.name,
        miembros: minka.members
      }));
    }
    // return await api.get(`/users/${userId}/minkas/simple`);
  }

  // Get individual users by ID (used by ValidarActoScreen)
  async getUserById(userId) {
    if (this.useMockData) {
      return getUserById(userId);
    }
    // return await api.get(`/users/${userId}`);
  }

  // Get individual actions by ID with basic info (used by ValidarActoScreen)  
  async getActionById(actionId) {
    if (this.useMockData) {
      return getActionById(actionId);
    }
    // return await api.get(`/actions/${actionId}/basic`);
  }

  // Get pending reports for validation (used by ValidarActoScreen)
  async getPendingReports() {
    if (this.useMockData) {
      return mockReports.filter(report => report.status === 'pending');
    }
    // return await api.get('/reports?status=pending');
  }

  // Get valoration data for specific action and minka (used by ValorarAccionScreen)
  async getValorationData(actionId, minkaId = 'pescadores') {
    if (this.useMockData) {
      const action = getActionById(actionId);
      
      if (!action) return null;

      // Get the minka doing the valoration
      const minkaValorando = mockMinkas.find(m => m.id === minkaId) || 
        { id: 'pescadores', name: 'Pescadores', members: 85 };

      // For ValorarAccionScreen, we need to determine which minka is affected
      // This should come from an existing valuation or be selected by the user
      // For now, default to the same minka
      const minkaAfectada = minkaValorando;

      return {
        accion: {
          id: action.id,
          nombre: action.name,
          descripcion: `# ${action.name}\n\n${action.description}`
        },
        minkaValorandoId: minkaValorando.id,
        minkaValorando: {
          id: minkaValorando.id,
          nombre: minkaValorando.name,
          miembros: minkaValorando.members
        },
        minkaAfectada: {
          id: minkaAfectada.id,
          nombre: minkaAfectada.name,
          miembros: minkaAfectada.members
        }
      };
    }
    // return await api.get(`/actions/${actionId}/valoration-data?minkaId=${minkaId}`);
  }

  // Submit karma valuation (used by ValorarAccionScreen)
  async submitKarmaValuation(valorationData) {
    if (this.useMockData) {
      // Save the valuation using the mock function
      const newValuation = mockSaveValuation(
        valorationData.minkaId, 
        valorationData.actionId, 
        {
          associatedMinka: valorationData.associatedMinka,
          complement: valorationData.complement,
          value: valorationData.karmaValue,
          totalImpact: valorationData.totalImpact
        }
      );
      
      return {
        success: true,
        message: 'Valoración guardada exitosamente',
        valuation: newValuation
      };
    }
    // return await api.post('/valuations', valorationData);
  }

  // Create new minka (used by CrearMinkaScreen)
  async createMinka(minkaData) {
    if (this.useMockData) {
      const newMinka = {
        id: `minka-${Date.now()}`,
        name: minkaData.nombre,
        description: minkaData.descripcion,
        icon: minkaData.icon,
        iconColor: minkaData.iconColor,
        parentId: minkaData.parentMinkaId,
        creatorId: minkaData.creatorId,
        members: 1, // Creator starts as first member
        balance: '₭ 0',
        isPositive: true,
        actions: [],
        subMinkas: [],
        createdAt: minkaData.createdAt
      };

      // Add to minkas array
      mockMinkas.push(newMinka);

      // Add creator to minka membership
      if (!mockUserMinkas[minkaData.creatorId]) {
        mockUserMinkas[minkaData.creatorId] = [];
      }
      mockUserMinkas[minkaData.creatorId].push(newMinka.id);

      // If there's a parent, add this as a sub-minka
      if (minkaData.parentMinkaId) {
        const parentMinka = mockMinkas.find(m => m.id === minkaData.parentMinkaId);
        if (parentMinka) {
          if (!parentMinka.subMinkas) {
            parentMinka.subMinkas = [];
          }
          parentMinka.subMinkas.push(newMinka.id);
        }
      }

      return {
        success: true,
        minka: newMinka,
        invitedUserIds: minkaData.invitedUserIds
      };
    }
    // return await api.post('/minkas', minkaData);
  }

  // NEW: Get available minkas for valuation target selection
  async getAvailableMinkas(currentMinkaId) {
    if (this.useMockData) {
      const currentMinka = mockMinkas.find(m => m.id === currentMinkaId);
      const availableMinkas = [
        { id: 'global', name: 'Global', type: 'global' }
      ];
      
      // Add current minka
      if (currentMinka) {
        availableMinkas.push({
          id: currentMinka.id,
          name: currentMinka.name,
          type: 'current'
        });
      }
      
      // Add sub-minkas
      if (currentMinka?.subMinkas) {
        currentMinka.subMinkas.forEach(subMinkaId => {
          const subMinka = mockMinkas.find(m => m.id === subMinkaId);
          if (subMinka) {
            availableMinkas.push({
              id: subMinka.id,
              name: subMinka.name,
              type: 'sub'
            });
          }
        });
      }
      
      return availableMinkas;
    }
    // return await api.get(`/minkas/${currentMinkaId}/available-for-valuation`);
  }
}

// Export singleton instance
export const dataService = new DataService(true); // true = use mock data

// Export class for testing
export default DataService;


//src/styles/theme.js

export const theme = {
  colors: {
    primary: {
      light: 'bg-blue-50',
      default: 'bg-blue-600',
      dark: 'bg-blue-700',
      text: 'text-blue-600',
      textDark: 'text-blue-700',
    },
    secondary: {
      light: 'bg-purple-50',
      default: 'bg-purple-500',
      text: 'text-purple-600',
    },
    success: {
      light: 'bg-green-50',
      text: 'text-green-600',
      textDark: 'text-green-700',
    },
    danger: {
      light: 'bg-red-50',
      text: 'text-red-500',
      textDark: 'text-red-600',
    },
    neutral: {
      light: 'bg-gray-50',
      lighter: 'bg-gray-100',
      text: 'text-gray-500',
      textDark: 'text-gray-700',
      textDarker: 'text-gray-800',
    },
  },
  gradients: {
    primary: 'bg-gradient-to-r from-green-700 to-green-800',
    total: 'bg-gradient-to-r from-blue-50 to-green-50',
  }
};


//src/utils/navigation.js




